(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{377:function(t,s,r){"use strict";r.r(s);var a=r(5),o=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"服务器端配置pac脚本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务器端配置pac脚本"}},[t._v("#")]),t._v(" 服务器端配置PAC脚本")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("参考")]),t._v(" "),r("p",[t._v("【1】 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file",target:"_blank",rel:"noopener noreferrer"}},[t._v("代理自动配置文件（PAC）文件"),r("OutboundLink")],1)])]),t._v(" "),r("p",[r("strong",[t._v("什么是PAC？")]),r("br"),t._v("\n代理自动配置（PAC）文件是一个 JavaScript 脚本，其核心是一个 JavaScript 函数，用来决定网页浏览请求（HTTP、HTTPS，和 FTP）应当直连目标地址，还是被转发给一个网页代理服务器并通过代理连接。")]),t._v(" "),r("p",[r("strong",[t._v("PAC脚本怎么写？")])]),t._v(" "),r("p",[t._v("PAC文件的核心JavaScript函数通常是这样定义的：")]),t._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("FindProxyForURL")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("url"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("host")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("p",[r("strong",[r("code",[t._v("url")])]),t._v(": 要访问的URL，URL中的类似于"),r("code",[t._v("https://")]),t._v("这样的路径和查询组件已经被去除。在Chrome浏览器中，可以通过设置"),r("code",[t._v("PacHttpsUrlStrippingEnabled")]),t._v("为"),r("code",[t._v("false")]),t._v("来禁止这种行为，或者使用"),r("code",[t._v("--unsafe-pac-url")]),t._v("命令行参数启动（Chrome 75以后的版本无法禁用这一行为）；其次在firefox浏览器中，对应的选项是"),r("code",[t._v("network.proxy.autoconfig_url.include_path")])]),t._v(" "),r("p",[r("strong",[r("code",[t._v("host")])]),t._v(": 从URL中提取到的主机名，他是"),r("code",[t._v("://")]),t._v("之后到第一个"),r("code",[t._v("/")]),t._v("之间的字符串，端口号不包括在此参数中。")]),t._v(" "),r("p",[r("strong",[t._v("描述")]),r("br"),t._v("\n返回一个描述了代理设置的字符串。字符串的格式按照返回值格式进行定义。")]),t._v(" "),r("p",[r("strong",[t._v("返回值格式")]),r("br"),t._v("\nFindProxyForURL() 函数返回一个字符串"),r("br"),t._v("\n如果那个字符串为空，则不使用任何代理"),r("br"),t._v("\n字符串中可以包含如下任意数量的“代理配置块”（building blocks），用分号分隔："),r("br"),t._v(" "),r("strong",[t._v("DIRECT")]),t._v(" ：直连，不经过任何代理"),r("br"),t._v(" "),r("strong",[t._v("PROXY host:port")]),t._v(" ：HTTP 代理"),r("br"),t._v(" "),r("strong",[t._v("SOCKS host:port")]),t._v(" ：SOCKS 代理")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("多个分号分隔的代理配置")]),t._v(" "),r("p",[t._v("如果有多个使用分号分隔的代理配置，将使用最左边的配置，除非 Firefox 无法与其中指定的代理服务器建立连接。在这种情况下，将使用下一个配置，等等。")]),t._v(" "),r("p",[t._v("30 分钟后，浏览器将自动重试之前没有响应的代理。下一次尝试则将在一小时后开始，再下一次是一个半小时。每次尝试后，间隔会增加 30 分钟。")]),t._v(" "),r("p",[t._v("如果所有代理都挂了，并且最后没有指定直连配置项（DIRECT），浏览器将询问是否应该暂时忽略代理，并尝试直接连接。20 分钟后，浏览器会再次询问是否应该重试代理，40 分钟后会再问一次。每次询问后，间隔会增加 20 分钟。")])]),t._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),r("ul",[r("li",[t._v("PAC文件应保存为"),r("code",[t._v("proxy.pac")])]),t._v(" "),r("li",[t._v("测试语法是否符合要求:"),r("code",[t._v("pactester -p path/proxy.pac -u url")])])])])])}),[],!1,null,null,null);s.default=o.exports}}]);