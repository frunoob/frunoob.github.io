(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{323:function(r,e,n){"use strict";n.r(e);var t=n(5),o=Object(t.a)({},(function(){var r=this,e=r.$createElement,n=r._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("h1",{attrs:{id:"朗新科技有限公司一面准备"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#朗新科技有限公司一面准备"}},[r._v("#")]),r._v(" 朗新科技有限公司一面准备")]),r._v(" "),n("p",[n("strong",[r._v("自我介绍")]),n("br"),r._v("\n面试官你好，我就读于河北工程大学软件工程专业，本科阶段学习的课程有Java程序开发，C/C++基础，Linux基础，还有计算机网络，操作系统，计组，数据结构与算法等课程。")]),r._v(" "),n("p",[n("strong",[r._v("JVM的理解")]),n("br"),r._v("\nJVM是包含在JDK中的，主要是用来对字节码文件进行解释的。也正是有了JVM，才能实现在不同平台上运行同一个字节码文件。\nJVM虚拟机最主要的就是他的内存分配了，JVM虚拟机主要分为")]),r._v(" "),n("p",[n("strong",[r._v("多线程了解吗，创建多线程的方式")])]),r._v(" "),n("p",[r._v("一般情况下只有一个线程，只有当主线程中的方法执行完毕才能继续执行下面的语句。为了充分的利用这个多核cpu，于是出现了多线程。"),n("br"),r._v("\n创建多线程的方式有很多，比如"),n("br"),r._v("\n继承Thread类，重写run方法；"),n("br"),r._v("\n实现Runnable方法，重写run方法；"),n("br"),r._v("\n实现Callable接口，重写call方法，"),n("br"),r._v("\n使用线程池来创建。")]),r._v(" "),n("p",[n("strong",[r._v("线程池了解吗，如何创建线程池？")])]),r._v(" "),n("p",[r._v("使用构造方法来实现ThreadPoolExecutor。"),n("br"),r._v("\n它包含了四个构造方法。其中的参数我们来看看\ncorePoolSize:核心线程数量；"),n("br"),r._v("\nmaxPoolSize：最大线程数；"),n("br"),r._v("\nKeepAliveTime TimeUnit：核心程序外的线程最大存活时间"),n("br"),r._v("\nTimeUnit： 时间单位"),n("br"),r._v("\nBlockingQueue： 等待队列；"),n("br"),r._v("\nThreadFactory： 线程工厂"),n("br"),r._v("\nRejectedExecutionHandler： 拒绝策略  （抛异常，不处理，丢弃最早未处理的任务）")]),r._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202204181315912.png",alt:""}})]),r._v(" "),n("p",[r._v("使用Executors类来创建：弊端是FixedThreadPool（线程数固定）和SingleThreadExcutor（只有一个线程）允许的i请求队列的最大长度为整数最大长度，可能导致内存溢出。"),n("br"),r._v("\nCachedThreadPool（线程数不确定，动态可变）和ScheduledThreadPool：允许的创建线程数量为整数最大值，可能创建大量线程造成内存溢出。")])])}),[],!1,null,null,null);e.default=o.exports}}]);