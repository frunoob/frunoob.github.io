(window.webpackJsonp=window.webpackJsonp||[]).push([[355],{560:function(t,a,n){"use strict";n.r(a);var e=n(5),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"数据库自动分区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库自动分区"}},[t._v("#")]),t._v(" 数据库自动分区")]),t._v(" "),n("h2",{attrs:{id:"partition-的一些限制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#partition-的一些限制"}},[t._v("#")]),t._v(" partition 的一些限制")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("分区所涉及的列必须是"),n("strong",[t._v("每一个")]),t._v("主键和唯一键的子集")])]),t._v(" "),n("li",[n("p",[t._v("关于InnoDB引擎的限制\nInnoDB存储引擎中，分区和外键不兼容，不能同时使用。\n"),n("code",[t._v("ALTER TABLE ... OPTIMIZE PARTITION")]),t._v("语句不能正常使用，用"),n("code",[t._v("ALTER TABLE ... REBUILD PARTITION and ALTER TABLE ... ANALYZE PARTITION")]),t._v("代替\n不要给任何分区或任何子分区指定存储引擎，因为同一个表的所有分区的存储引擎必须一致。")])]),t._v(" "),n("li",[n("p",[t._v("关于一些sql函数的限制"),n("br"),t._v("\n只有以下函数能够在分区表达式中使用（注意不是mysql语句，是创建表时的分区表达式）\nABS()")]),t._v(" "),n("p",[t._v("CEILING() (see CEILING() and FLOOR())")]),t._v(" "),n("p",[t._v("DATEDIFF()")]),t._v(" "),n("p",[t._v("DAY()")]),t._v(" "),n("p",[t._v("DAYOFMONTH()")]),t._v(" "),n("p",[t._v("DAYOFWEEK()")]),t._v(" "),n("p",[t._v("DAYOFYEAR()")]),t._v(" "),n("p",[t._v("EXTRACT() (see EXTRACT() function with WEEK specifier)：有个BUG：指定单元为 WEEK 时，不允许将其作为分区函数")]),t._v(" "),n("p",[t._v("FLOOR() (see CEILING() and FLOOR())")]),t._v(" "),n("p",[t._v("HOUR()")]),t._v(" "),n("p",[t._v("MICROSECOND()")]),t._v(" "),n("p",[t._v("MINUTE()")]),t._v(" "),n("p",[t._v("MOD()")]),t._v(" "),n("p",[t._v("MONTH()")]),t._v(" "),n("p",[t._v("QUARTER()")]),t._v(" "),n("p",[t._v("SECOND()")]),t._v(" "),n("p",[t._v("TIME_TO_SEC()")]),t._v(" "),n("p",[t._v("TO_DAYS()")]),t._v(" "),n("p",[t._v("TO_SECONDS()")]),t._v(" "),n("p",[t._v("UNIX_TIMESTAMP() (with TIMESTAMP columns)")]),t._v(" "),n("p",[t._v("WEEKDAY()")]),t._v(" "),n("p",[t._v("YEAR()")]),t._v(" "),n("p",[t._v("YEARWEEK()")])]),t._v(" "),n("li",[n("p",[t._v("关于"),n("strong",[t._v("锁")]),t._v("的限制\nselect 只锁包含要查询的数据的分区\nupdate 只有当"),n("strong",[t._v("没有分区列被更新的时候")]),t._v("才不用全表锁\ninsert 只有要被新增的分区加锁。但如果设置了自增列，则全表全分区锁")])])]),t._v(" "),n("div",{staticClass:"language-sql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sql"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" employees "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    id "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    fname "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    lname "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    hired "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATE")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1970-01-01'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    separated "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATE")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'9999-12-31'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    job_code "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    store_id "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" RANGE "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("store_id"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" p0 "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" LESS THAN "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" p1 "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" LESS THAN "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" p2 "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" LESS THAN "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" p3 "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" LESS THAN "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("21")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n")])])]),n("p",[t._v("通过sql语句来创建带有分区选项的表。")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("创建分区的提示")]),t._v(" "),n("p",[t._v("分区的定义需要从低到高来排序，不可以打乱顺序。")])]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("提高查询速度的建议")]),t._v(" "),n("p",[t._v("where查询条件最好包含分区列 并使用"),n("code",[t._v("=,<, >, <=, >=, and <>")]),t._v("或者"),n("code",[t._v("IN ()")]),t._v(" 表达式，这样查询的时候mysql会自动忽略不包含目标数据的分区，只查询包含目标数据的分区，从而提高查询速度")])]),t._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",{staticClass:"custom-block-title"},[t._v("注意null")]),t._v(" "),n("p",[t._v("在list分区中，插入null数据会导致报错， 必须显式定义一个包含null的list分区")]),t._v(" "),n("p",[t._v("在hash 和range中，null被当作是最小的 存放在第一个分区")])]),t._v(" "),n("h2",{attrs:{id:"使用分区遇到的一些问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用分区遇到的一些问题"}},[t._v("#")]),t._v(" 使用分区遇到的一些问题")]),t._v(" "),n("p",[t._v("数据库表使用了主键，但是由于主键必须包含分区列。此时可以删除原有主键，创建一个新的联合主键，新的主键不能是null；")]),t._v(" "),n("div",{staticClass:"language-sql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sql"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALTER")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("column1"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("column2"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),n("h2",{attrs:{id:"自动定时分区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自动定时分区"}},[t._v("#")]),t._v(" 自动定时分区")]),t._v(" "),n("h3",{attrs:{id:"查询定时事件event-scheduler是否开启"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#查询定时事件event-scheduler是否开启"}},[t._v("#")]),t._v(" 查询定时事件event_scheduler是否开启")]),t._v(" "),n("p",[n("code",[t._v("show variables like '%event_scheduler';")])]),t._v(" "),n("h3",{attrs:{id:"开启时间定时计划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开启时间定时计划"}},[t._v("#")]),t._v(" 开启时间定时计划")]),t._v(" "),n("p",[n("code",[t._v("set global event_scheduler=on;")])]),t._v(" "),n("h3",{attrs:{id:"创建存储过程stored-procedures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建存储过程stored-procedures"}},[t._v("#")]),t._v(" 创建存储过程stored procedures")]),t._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[t._v("需要提前配置的事项")]),t._v(" "),n("p",[t._v("需要提前启用分区，并手动创建一些分区")]),t._v(" "),n("p",[t._v("在分区之间需要将被分区的字段添加到主键里。")]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("-- 先将主键的自增去掉，不然没法删除主键\nalter table <table_name>\n    modify <your_id> bigint not null comment '自增主键';\n-- 删除主键\nalter table <table_name>\n    drop primary key;\n-- 添加新的主键，让主键包含被分区的字段\nalter table <table_name>\n    add primary key (<your_id>, <time>);\n\n")])])]),n("p",[n("strong",[t._v("按年分区")])]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ALTER TABLE  <table_name>  PARTITION BY RANGE (to_days(<time>)) (\n        PARTITION <prefix>2024  VALUES LESS THAN to_days('20250101'),\n        PARTITION <prefix>other  VALUES LESS THAN MAXVALUE );\n\n")])])]),n("p",[n("strong",[t._v("按月分区")])]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\nALTER TABLE  <table_name>  PARTITION BY RANGE (to_days(create_time)) (\n        PARTITION <prefix>202407  VALUES LESS THAN to_days('20230801'),\n        PARTITION <prefix>other  VALUES LESS THAN MAXVALUE );\n\n")])])]),n("p",[n("strong",[t._v("按日分区")])]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ALTER TABLE  bn_load_profile  PARTITION BY RANGE (to_days(value_time)) (\n        PARTITION <prefix>20240607  VALUES LESS THAN to_days('20240608'),\n        PARTITION <prefix>other  VALUES LESS THAN MAXVALUE );\n")])])])]),t._v(" "),n("p",[t._v("下面是创建存储过程的代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("create definer = root@`%` procedure add_partition_if_not_exists(IN t_name varchar(64), IN partition_date date, IN partition_type varchar(10), IN prefix varchar(20))\nBEGIN\n    DECLARE p_name VARCHAR(30);\n    DECLARE partition_exists INT;\n    IF partition_type = 'DAILY' THEN\n        SET p_name = DATE_FORMAT(partition_date, CONCAT(prefix,'%Y%m%d'));\n        SET @partition_value = CONCAT('TO_DAYS(''', DATE_ADD(partition_date,interval 1 day ), ''')');\n    ELSEIF partition_type = 'MONTHLY' THEN\n        SET p_name = DATE_FORMAT(partition_date, CONCAT(prefix,'%Y%m'));\n        SET @partition_value = CONCAT('TO_DAYS(''', DATE_ADD(partition_date,interval 1 month), ''')');\n    ELSEIF partition_type = 'YEARLY' THEN\n        SET p_name = DATE_FORMAT(partition_date, CONCAT(prefix,'%Y'));\n        SET @partition_value = CONCAT('TO_DAYS(''', DATE_ADD(partition_date,interval 1 year), ''')');\n    END IF;\n\n\n    -- 检查分区是否存在\n    SET partition_exists = (SELECT COUNT(1)\n                            FROM information_schema.PARTITIONS\n                            WHERE TABLE_SCHEMA = DATABASE()\n                              AND TABLE_NAME = t_name\n                              AND PARTITION_NAME = p_name);\n    -- 如果分区不存在，则添加\n    IF partition_exists = 0 THEN\n        SET @sql = CONCAT('ALTER TABLE ', t_name, ' REORGANIZE PARTITION ',prefix,'other INTO ( PARTITION ', p_name, ' VALUES LESS THAN (', @partition_value, '),PARTITION ',prefix,'other VALUES LESS THAN MAXVALUE)');\n        PREPARE stmt FROM @sql;\n        EXECUTE stmt;\n        DEALLOCATE PREPARE stmt;\n    END IF;\nEND;\n\n\n")])])]),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("如何调用")]),t._v(" "),n("p",[t._v("要调用改存储过程，只需要执行"),n("code",[t._v("call add_partition_if_not_exists(表名，分区日期，分区类型，分区名称前缀prefix)")]),t._v("\n其中，分区类型有三种分别是\t"),n("code",[t._v("DAILY")]),t._v(","),n("code",[t._v("MONTHLY")]),t._v(", "),n("code",[t._v("YEARLY")]),t._v("，举例说明:"),n("code",[t._v("DAILY")]),t._v("类型代表按日分区，每天分区,分区名称格式是"),n("code",[t._v("<prefix>20240607")]),t._v("，该分区的对应的值是2024年6月8号0点的时间戳;同理，"),n("code",[t._v("MONTHLY")]),t._v("代表"),n("strong",[t._v("按月分区")]),t._v("，分区名称格式是"),n("code",[t._v("<prefix>202406")]),t._v(",对应的值是下一个月1号的时间戳;最后一个代表的"),n("strong",[t._v("按年分区")]),t._v("，分区名称格式是"),n("code",[t._v("<prefix>2024")]),t._v("，对应的值是下一年的一月一号的时间戳。")])]),t._v(" "),n("p",[t._v("可以再创建一个存储过程")]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("create definer = root@`%` procedure daily_manage_partitions()\nBEGIN\n    DECLARE current_now_d DATE;\n    DECLARE current_now_m DATE;\n    DECLARE current_now_y DATE;\n    DECLARE end_date_d DATE;\n    DECLARE end_date_m DATE;\n    DECLARE end_date_y DATE;\n    DECLARE p_type_day VARCHAR(20);\n    DECLARE p_type_month VARCHAR(20);\n    DECLARE p_type_year VARCHAR(20);\n\n#    分区类型\n    SET p_type_day = concat('DAILY');\n    SET p_type_month = concat('MONTHLY');\n    SET p_type_year = concat('YEARLY');\n\n#   起始时间\n    SET current_now_d = curdate();\n    set current_now_m = DATE(DATE_FORMAT(NOW(), '%Y-%m-01'));\n    set current_now_y = DATE(DATE_FORMAT(NOW(), '%Y-01-01'));\n\n    #结束时间\n    SET end_date_d = DATE_ADD(current_now_d,INTERVAL 1 year );\n    set end_date_m = DATE_ADD(current_now_m, interval 1 year );\n    set end_date_y = DATE_ADD(current_now_y, interval  2 year );\n\n    # 从今天开始，为'my_table_d'自动创建未来一年的分区（包含本日）,按日进行分区,每天一个分区，分区名称的前缀是 'd_'\n    WHILE  current_now_d < end_date_d DO\n\n            -- 需要修改表明和分区名称前缀\n            CALL add_partition_if_not_exists('my_table', current_now_d,p_type_day,'d_');\n\n            SET current_now_d = DATE_ADD(current_now_d, interval 1 day );\n        END WHILE;\n\n   # 从本月开始，为'my_table_m'自动创建未来一年的分区（包含本月），按月进行分区，每个月一个分区，分区的名称的前缀是 'm_'\n    WHILE  current_now_m < end_date_m DO\n\n            -- 需要修改表明和分区名称前缀\n            CALL add_partition_if_not_exists('my_table_m', current_now_m,p_type_month,'m_');\n\n            SET current_now_m = DATE_ADD(current_now_m, interval 1 month );\n        END WHILE;\n\n   # 从本年开始，为'my_table_y'自动创建两年的分区（包含本年），按年进行分区，没年一个分区，分区的名称的前缀是 'y_'\n    WHILE  current_now_y < end_date_y DO\n\n            -- 需要修改表明和分区名称前缀\n            CALL add_partition_if_not_exists('my_table_y', current_now_y,p_type_year,'y_'); \n\n            SET current_now_y = DATE_ADD(current_now_y, interval 1 year );\n        END WHILE;\nEND;\n")])])]),n("p",[t._v("最后只需要开启event_scheduler并创建新的event就可以实现每天自动创建分区了")]),t._v(" "),n("div",{staticClass:"language-mysql extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("-- 开启event_scheduler\nset global  event_scheduler  = ON;\n\n-- 创建event\ncreate definer = root@`%` event scheduled_task on schedule\n        -- 每两个小时执行一个，如果要每天的话就是 1 DAY 每个月（1 MONTH） 每秒(1 second) 每分钟(1 minute)\n\tevery '2' hour\n        -- 开始时间，now() 代表是当前时间，从当前时间开始，每两个小时执行一次；DATE_ADD(now(),interval 5 second )代表的是5秒之后执行\n\tstarts DATE_ADD(now(),interval 5 second )\n\tenable\n\tdo\n\tBEGIN\n        call daily_manage_partitions;\n    \tEND;\n-- 查询时间的执行记录\nselect * from mysql.event;\n\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);