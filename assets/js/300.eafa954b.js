(window.webpackJsonp=window.webpackJsonp||[]).push([[300],{504:function(t,s,a){"use strict";a.r(s);var _=a(5),v=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"高并发系统的设计与开发-java"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高并发系统的设计与开发-java"}},[t._v("#")]),t._v(" 高并发系统的设计与开发|java")]),t._v(" "),a("h2",{attrs:{id:"第二章-高并发io的底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二章-高并发io的底层原理"}},[t._v("#")]),t._v(" 第二章：高并发IO的底层原理")]),t._v(" "),a("h3",{attrs:{id:"_2-1-io读写的基本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-io读写的基本"}},[t._v("#")]),t._v(" 2.1 IO读写的基本")]),t._v(" "),a("p",[t._v("为了保证内核安全，操作系统将内存分为两个部分，用户空间和内核空间。内核程序运行在内核空间，对应的进程处于内核态。用户程序运行在用户空间，对应进程处于用户态。")]),t._v(" "),a("p",[t._v("操作系统的核心是内核程序，它有权限访问内核空间，也能访问硬件。")]),t._v(" "),a("p",[t._v("用户程序如果想要访问内核空间中的数据，需要将进程状态转换为内核态。")]),t._v(" "),a("p",[t._v("内核态进程可以执行任意命令，调用系统的一切资源。 如果用户进程想要访问系统资源，必须通过系统调用。")]),t._v(" "),a("p",[a("strong",[t._v("缓冲区")]),t._v("是为了解决cpu和IO之间速度不匹配，减少cpu中断而存在的。")]),t._v(" "),a("h4",{attrs:{id:"_2-1-1-内核缓冲区和进程缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-内核缓冲区和进程缓冲区"}},[t._v("#")]),t._v(" 2.1.1 内核缓冲区和进程缓冲区")]),t._v(" "),a("p",[t._v("当IO操作将内核缓冲区装满后，由系统判断何时中断设备，不需要应用操心。\n上层应用使用read调用时，将数据从内核缓冲区复制到进程的缓冲区。")]),t._v(" "),a("h2",{attrs:{id:"_2-2-四种主要的io模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-四种主要的io模型"}},[t._v("#")]),t._v(" 2.2 四种主要的IO模型")]),t._v(" "),a("p",[t._v("四种常见IO模型")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("阻塞和非阻塞")]),t._v(" "),a("p",[t._v("阻塞IO是在内核IO操作彻底完成才返回用户空间执行用户程序的操作指令。 java中创建的socket都属于阻塞IO模型。")])]),t._v(" "),a("p",[a("strong",[t._v("1.同步阻塞IO")])]),t._v(" "),a("p",[t._v("用户空间中的线程发起IO请求, 然后该线程进入阻塞状态，等内核进程彻底完成IO操作后，线程恢复。")]),t._v(" "),a("p",[a("strong",[t._v("2.同步非阻塞IO")])]),t._v(" "),a("p",[t._v("用户空间的程序不需要等待内核缓冲区准备数据，可以立即返回用户空间去执行后续的指令。通过不断的发起系统调用，直到内核缓冲区数据准备完成。")]),t._v(" "),a("p",[t._v("非阻塞会占用大量cpu时间，效率低下。")]),t._v(" "),a("p",[a("strong",[t._v("3.IO多路复用")])]),t._v(" "),a("p",[t._v("通过注册器统一管理IO请求，注册器循环查询准备就绪的线程，汇总成表返回到用户空间")]),t._v(" "),a("p",[a("strong",[t._v("4.异步IO")])]),t._v(" "),a("p",[t._v("系统调用的过程中，用户程序不阻塞，当资源复制到用户空间之后，通知用户处理，全程用户进程都不会阻塞。"),a("br"),t._v("\n理论上 异步IO的吞吐量高于IO多路复用模型的吞吐量。window下通过"),a("strong",[t._v("IOCP")]),t._v("实现了真正的异步IO"),a("br"),t._v("\nlinux2.6版本以后才有的aio,jdk对其支持并不完善，性能提升不大")]),t._v(" "),a("h2",{attrs:{id:"_2-3-通过合理配置支持百万并发连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-通过合理配置支持百万并发连接"}},[t._v("#")]),t._v(" 2.3 通过合理配置支持百万并发连接")]),t._v(" "),a("p",[t._v("在linux中，文件句柄默认1024,即一个进程最多可以接受1024个socket连接，这是远远不够的。"),a("br"),t._v("\n文件句柄也称文件描述符，在Linux系统中，文件描述符是内核为了高校管理已经被打开的问i按所创建的索引，是一个非负数，用于指代被打开的文件。所有的IO系统调用都是通过文件描述符来完成的。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看文件句柄限制 ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("ulimit")]),t._v(" -d   \n\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置文件句柄数量，仅对当前用户的当前shell界面生效  ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("ulimit")]),t._v(" -n "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000000")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 编辑 /etc/rc.local ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("ulimit")]),t._v(" -SHn "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000000")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ")]),t._v("\n\n")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);