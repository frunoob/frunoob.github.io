(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{328:function(v,r,t){"use strict";t.r(r);var a=t(5),_=Object(a.a)({},(function(){var v=this,r=v.$createElement,t=v._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"jvm基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm基础"}},[v._v("#")]),v._v(" JVM基础")]),v._v(" "),t("blockquote",[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#java基础知识"}},[v._v("java基础知识")]),t("ul",[t("li",[t("a",{attrs:{href:"#抽象类与接口"}},[v._v("抽象类与接口")])]),t("li",[t("a",{attrs:{href:"#string为什么不可变"}},[v._v("String为什么不可变")])])])]),t("li",[t("a",{attrs:{href:"#jvm"}},[v._v("JVM")]),t("ul",[t("li",[t("a",{attrs:{href:"#jvm内存区"}},[v._v("JVM内存区")])]),t("li",[t("a",{attrs:{href:"#垃圾回收与算法"}},[v._v("垃圾回收与算法")])]),t("li",[t("a",{attrs:{href:"#java中的四种引用"}},[v._v("Java中的四种引用")])]),t("li",[t("a",{attrs:{href:"#垃圾收集器"}},[v._v("垃圾收集器")])]),t("li",[t("a",{attrs:{href:"#java网络编程模型"}},[v._v("Java网络编程模型")])])])])])]),t("p")]),v._v(" "),t("h2",{attrs:{id:"java基础知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java基础知识"}},[v._v("#")]),v._v(" java基础知识")]),v._v(" "),t("h3",{attrs:{id:"抽象类与接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类与接口"}},[v._v("#")]),v._v(" 抽象类与接口")]),v._v(" "),t("p",[t("strong",[v._v("相同点")])]),v._v(" "),t("ol",[t("li",[v._v("都不能实例化")]),v._v(" "),t("li",[v._v("子类在继承的过程中必须要实现所有的抽象方法")])]),v._v(" "),t("p",[t("strong",[v._v("不同点")])]),v._v(" "),t("ol",[t("li",[v._v("接口中的函数必须是抽象函数，而抽象类中的抽象函数可以是实现了的（即普通函数）")]),v._v(" "),t("li",[v._v("一个类可以实现多个接口，但是只能继承一个抽象类")]),v._v(" "),t("li",[v._v("抽象类中的成员变量可以被public，private，protect修饰，但是成员函数不能用praviate,static,synchronized和native等访问修饰符修饰；而接口中所有成员变量都强制默认是public，static，final修饰的，所有成员函数都是public，abstract修饰的。抽象类中可以有非抽象成员函数，所以当功能需要累积时，使用抽象类；不需要累积的时候使用接口。")]),v._v(" "),t("li",[v._v("在设计理念上来说的话："),t("strong",[v._v("抽象类")]),v._v("更倾向于所属关系，即当多个类具有相同的属性定义和功能（实现方式不同）时，可以将其升级成一个抽象类，再由多个子类来继承；"),t("strong",[v._v("接口")]),v._v("则是当多个类有相同的功能且实现方式相同且未来不会出现功能累积的情况时，接口强调的是特定功能的实现。")]),v._v(" "),t("li",[v._v("接口用于实现常用的功能，便于日后的维护和更新；抽象类充当了公共类的角色，不适用于日后的重新对代码进行修改。")])]),v._v(" "),t("h3",{attrs:{id:"string为什么不可变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string为什么不可变"}},[v._v("#")]),v._v(" String为什么不可变")]),v._v(" "),t("p",[v._v("这个问题可以从两个角度进行理解：")]),v._v(" "),t("ol",[t("li",[v._v("第一个是为什么String能不可变，首先String类是final的，该类不能被继承，自然其中的函数就不能被重写；然后String类中的Btye数组也是final类型，这就决定了String类一旦被定义必然不能被再次修改了。")]),v._v(" "),t("li",[v._v("第二个是为什么String类要不可变，在hashmap中，键必须是唯一的不可重复的，而且在检查键是否存在的时候是先检查键的hash值是否相等，如果相等再检查内容是否相同。一般情况，我们一般使用String作为键，因为String在创建的时候就生成对应的hash值并且由于String是不可变的，所以hash值也是固定的，这样相对于其他的对象而言，在hashmap中String的检索速度更快。同时字符串不可变时，字符串常量池来能够实现，字符串常量池能够节省空间，因为不同的字符串变量指向同一个字符串；")])]),v._v(" "),t("h2",{attrs:{id:"jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),t("h3",{attrs:{id:"jvm内存区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存区"}},[v._v("#")]),v._v(" JVM内存区")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202204161014761.webp",alt:""}}),t("br"),v._v("\n上图所示为JDK8的JVM内存模型")]),v._v(" "),t("p",[v._v("1."),t("strong",[v._v("pc Register")]),v._v("（程序计数器）线程私有，当方法执行时，计数器记录的是实时虚拟机字节码指令的地址；如果该方法执行的是Native方法，则程序计数器的值为Undefined。"),t("br"),v._v("\n2."),t("strong",[v._v("虚拟机栈")]),v._v("记录的是方法的局部变量，操作栈，返回地址，动态链接，每一个线程在运行过程中只有当前一个栈帧是处于活动状态。")]),v._v(" "),t("p",[v._v("3."),t("strong",[v._v("堆")]),v._v("(heap)：分为新生代和老年代，新生代中分为三个区域分别是Eden、survivorFrom、survivorTo三个区域，其空间占比依次是8:1:1。"),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202204161543126.png",alt:""}})]),v._v(" "),t("p",[t("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#default_arrangement_gen",target:"_blank",rel:"noopener noreferrer"}},[v._v("点此查看原图出处"),t("OutboundLink")],1),t("br"),v._v("\n当实例化对象时，先将对象存放到Eden区，如果对象是大对象就将其放入到永久代中（java8中的元数据区Metaspace取代了永久代，两者的区别主要是元数据区没有使用虚拟机内存而是直接使用系统内存，java8中JVM将类的元数据放在本地内存中）。如果Eden区放满了的话就会触发GC进行垃圾回收，在新生代垃圾回收主要是通过"),t("strong",[v._v("复制算法")]),v._v("实现的，算法过程如下：")]),v._v(" "),t("p",[v._v("首先标记Eden和survivorFrom中的存活对象，然后将其转移到SurvivorTo中，再将Eden和survivorFrom中的对象清除，最后把survivorTo中的对象复制到survivorFrom中。")]),v._v(" "),t("p",[v._v("Servivor区的对象每经过一次GC后仍然存活，则年龄加一。默认情况下年龄达到老年代要求时就会转移到老年代。")]),v._v(" "),t("p",[t("strong",[v._v("新生代大小的选择")]),v._v(" 需要更具用户的要求，在暂停时间和吞吐量上进行权衡。暂停时间指的是应用程序在垃圾回收过程中出现的无响应的时间；吞吐量指一段时间内，没有花费在垃圾回收的时间占全部时间的比重（吞吐量包含内存分配的时间）")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),t("p",[v._v("java8将类的元数据放在系统的本地内存，将常量池和静态变量放在Java堆中")])]),v._v(" "),t("p",[v._v("GC不会在运行期间对永久代的内存进行清理，会导致Class加载越来越多，java8将类保存到本地内存可以有效的解决这个问题。")]),v._v(" "),t("h3",{attrs:{id:"垃圾回收与算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收与算法"}},[v._v("#")]),v._v(" 垃圾回收与算法")]),v._v(" "),t("p",[t("strong",[v._v("确定垃圾的方法")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("引用计数法")]),t("br"),v._v("\n当为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减一，如果一个对象的引用计数为0，那么就代表这个对象没有引用，就可以被回收了。"),t("br"),v._v("\n引用计数法可能到时"),t("strong",[v._v("循环引用")]),v._v("： 两个对象互相引用。从而导致回收器无法对其进行回收。")]),v._v(" "),t("li",[t("strong",[v._v("可达性分析法")]),t("br"),v._v("\njvm会设定几个根节点（GC Roots），如果对象无法通过引用连接到根结点的话，就说明该对象时不可达的。至少两次标记才能断定他是不可达的。")])]),v._v(" "),t("p",[t("strong",[v._v("常见的垃圾回收算法")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("标记清理算法")]),t("br"),v._v("\n分为标记和清理两个阶段，首先标记可回收的对象，然后对可回收对象进行清理。"),t("br"),v._v(" "),t("strong",[v._v("缺点")]),v._v("产生碎片，因为清理后的区域不会进行碎片整理。")]),v._v(" "),t("li",[t("strong",[v._v("复制")]),v._v("（新生代常用）"),t("br"),v._v("\n两个一样大的区域，其中一个区域存放对象，另一个区域是空的。回收的时候，先将存有对象的区域进行可回收对象标记，然后将其余的对象复制到别一个空区域中，最后清空原来的区域即可。"),t("br"),v._v("\n**缺点：**浪费了一半的空间。一般的空间都是无法使用的。")]),v._v(" "),t("li",[t("strong",[v._v("标记复制算法")]),t("br"),v._v("\n结合了标记清理算法和复制算法的优点。回收过程时这样的，先对可回收对象进行标记，然后将存活对象复制到内存的另一端，然后清除该端的对象并释放内存。")]),v._v(" "),t("li",[t("strong",[v._v("分代收集算法")]),t("br"),v._v("\n根据对象的类型对JVM内存分为了新生代和老年代，新生代使用复制算法，常用来保存的是小对象和短周期对象，老年代时大对象和长周期对象，常常使用的时标记整理算法。新生代有划分成Eden区和里那个Survivor区，当Eden区或其中一个Survivor区满了的时候，就将触发GC，如果垃圾回收之后仍然无法装下新的对象就会将其放入到老年代中了。"),t("br"),v._v("\n方法区的永久代长存放常量，Class元数据，永久代回收废弃常量和无用的Class。")])]),v._v(" "),t("h3",{attrs:{id:"java中的四种引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中的四种引用"}},[v._v("#")]),v._v(" Java中的四种引用")]),v._v(" "),t("p",[t("strong",[v._v("强引用：")]),v._v(" 实例化对象时，将一个引用指向一个对象的时候，这个引用就是强引用。"),t("br"),v._v(" "),t("strong",[v._v("软引用")]),v._v("： 软引用只有当JVM内存空间不够的时候才会被清理。"),t("br"),v._v(" "),t("strong",[v._v("弱引用")]),v._v("：每次清理都会将弱引用清理掉。"),t("br"),v._v(" "),t("strong",[v._v("虚引用")]),v._v("：主要用于跟踪对象的垃圾回收状态。")]),v._v(" "),t("h3",{attrs:{id:"垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),t("p",[v._v("针对新生代的提供的垃圾收集器有Serial、ParNew、Parallel Scavenge"),t("br"),v._v("\n针对老年代提供的垃圾回收器有Serial Old、Parallel Old、CMS")]),v._v(" "),t("p",[t("strong",[v._v("GI垃圾收集器")]),v._v(" ：为了避免全区域的垃圾回收引起的系统停顿，将堆内存划分为大小固定的几个独立的区域，独立使用这些内存资源并跟踪这些区域的垃圾收集进度，同时后在后台维护一个优先级列表，在垃圾回收过程中，根据系统允许的最长的垃圾收集时间优先回收垃圾最多的区域。"),t("br"),v._v(" "),t("strong",[v._v("GI优点")]),v._v(" ： 基于标记整理算法，无碎片；精准控制停顿时间，在不牺牲吞吐量的前提下实现短暂垃圾回收。")]),v._v(" "),t("h3",{attrs:{id:"java网络编程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java网络编程模型"}},[v._v("#")]),v._v(" Java网络编程模型")]),v._v(" "),t("p",[t("strong",[v._v("阻塞I/O模型")]),t("br"),v._v("\n用户发送I/O请求之后，一直阻塞，直到内存数据准备就绪，内核将数据复制到用户线程中并返回I/O执行结果，客户端才退出阻塞状态并开始处理数据。"),t("br"),v._v(" "),t("strong",[v._v("非阻塞I/O模型")]),t("br"),v._v("\n用户不断询问内核数据是否准备就绪，询问期间用户线程不阻塞，当内核数据准备就绪时，内核就会立即将数据复制到用户线程中并将复制结果通知给用户线程。（数据复制过程中，用户线程时阻塞的）。"),t("br"),v._v(" "),t("strong",[v._v("多路复用I/O模型")]),t("br"),v._v("\n该模型时多线程并发编程中常常使用到的模型，Java NIO就是基于多路复用I/O模型实现的。"),t("br"),v._v("\n仅需要一个线程就可以管理多个Socket（阻塞I/O模型和非阻塞I/O模型需要为每一个用户线程提供一个Socket）而且多路复用I/O模型是在系统内核中进行Socket状态检查的，只有当Socket有书写事件时才会使用操作系统的I/O资源，大大节约了系统资源。")])])}),[],!1,null,null,null);r.default=_.exports}}]);