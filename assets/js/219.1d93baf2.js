(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{422:function(t,v,_){"use strict";_.r(v);var s=_(5),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"软考-计算机系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软考-计算机系统"}},[t._v("#")]),t._v(" 软考-计算机系统")]),t._v(" "),_("blockquote",[_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#数据的表示与校验码"}},[t._v("数据的表示与校验码")])])])]),_("p")]),t._v(" "),_("h2",{attrs:{id:"数据的表示与校验码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据的表示与校验码"}},[t._v("#")]),t._v(" 数据的表示与校验码")]),t._v(" "),_("p",[_("strong",[t._v("原码、反码、补码和移码")]),_("br"),t._v("\n原码： 首位代表数字的正负，其余部分是数字的绝对值。零有两种表示方式。"),_("br"),t._v("\n反码： 首位代表数字的正负，当数字为正数：原码与反码相等；当数字为负数：即符号位为1，其余部分在原码的基础上按位取反。"),_("br"),t._v("\n补码： 同样，最高位代表符号位，0为正，1为负。为正数时，原码=反码=补码；为负数时，补码等于反码+1。"),_("br"),t._v("\n移码： 在数字X的基础上增加一个偏移量，常常用于表示浮点数中的阶码。")]),t._v(" "),_("div",{staticClass:"custom-block danger"},[_("p",{staticClass:"custom-block-title"},[t._v("备忘")]),t._v(" "),_("p",[t._v("还是不太懂移码到底是怎么用的")])]),t._v(" "),_("p",[_("strong",[t._v("定点数和浮点数")]),_("br"),t._v("\n定点数包括定点整数（纯整数，小数点在最低有效数值之后）和定点小数（纯小数，小数点在最高有效数值之前）"),_("br"),t._v("\n浮点数就是小数点位置不固定的数，它能够表示更大范围的数字。浮点数表示法中，"),_("code",[t._v("阶码")]),t._v("通常为带符号的纯整数，"),_("code",[t._v("尾数")]),t._v("是带符号的纯小数。"),_("br"),t._v("\n浮点数的表示格式如图： | 阶符 | 阶码 | 数符 | 尾数 |"),_("br"),t._v("\n浮点数通常表示为： "),_("code",[t._v("N = M * R^E")]),_("br"),t._v("\nM为尾数，R为基数，E为阶码。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("工业标准 IEEE 754")]),t._v(" "),_("p",[t._v("IEEE754是由IEEE（电气电子工程师学会）制定的有关浮点数的工业标准，该标准的表示形式为: (-1)^s2^E(b_0b_1b_2...b_(p-1))"),_("br"),t._v("\n其中(-1)^s表示该浮点数的数符， 当s为0时为正数，1时为负数。E为指数（阶码），用移码表示。其余为尾数。长度为P，用原码表示。")])]),t._v(" "),_("p",[_("strong",[t._v("校验码")]),_("br"),t._v("\n计算机系统运行时，各个部件之间要进行数据交换，有两种方式：提高电路的可靠性 和 提高代码的校验能力，包括查错和纠错。通常使用校验码的方式来研策传送到数据是否出错。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("码距")]),t._v(" "),_("p",[t._v("所谓码距指的是一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。")])]),t._v(" "),_("div",{staticClass:"summary"},[_("p",{staticClass:"title"},[t._v("三种校验方式")]),_("ol",[_("li",[_("p",[t._v("奇偶校验")])]),t._v(" "),_("li",[_("p",[t._v("海明码")])]),t._v(" "),_("li",[_("p",[t._v("循环冗余校验码")])])]),t._v(" "),_("p",[t._v("循环冗余校验码由两个部分组成，左面为信息码，右面为校验码。如信息码占k位，则校验码占"),_("code",[t._v("n-k")]),t._v("位。n位CRC码的字长，所以又称为(n,k)码。校验码是由信息码产生的，校验码位数越长，改代码的校验能力越强，在求CRC编码时，采用的是模2运算，其加减运算是按位运算，不会发生借位或者错位。")])]),_("p",[_("strong",[t._v("虚拟存储器")]),_("br"),t._v("\n虚拟存储器由"),_("code",[t._v("主存-辅存")]),t._v("两级存储器组成。  虚拟存储器的作用是解决内存不足的问题，将硬盘存储当作内存来使用。")]),t._v(" "),_("p",[_("strong",[t._v("CPU内部")])]),t._v(" "),_("ol",[_("li",[t._v("控制器： 协调和指挥整个计算机系统的操作，是发布命令的决策机构，保证指令的正确执行，并且能够处理异常事件。"),_("br"),t._v("\n控制器由指令寄存器(IR)，程序计数器(PC)，地址寄存器(AR)，指令译码器(ID)组成。指令寄存器将从内存储器中取到缓冲寄存器中的指令暂存起来，然后指令译码器根据IR的内容将指令中的操作码进行分析，产生各种微操作指令，执行指令时，PC永远保存着下一条指令的地址，每执行一条指令时，CPU都将自动修改PC的内容，以便PC中保存的总是将要执行的下一条指令的地址。地址寄存器用于保存当前CPU访问的内存单元的地址，")]),t._v(" "),_("li",[t._v("运算器：负责算数运算和逻辑运算"),_("br"),t._v("\n运算器由四个部分组成，算术逻辑单元(负责算数和逻辑运算)、累加寄存器（简称累加器，是一个通用寄存器，其功能是当运算器的算术逻辑单元执行算数或逻辑运算时，提供工作区）、数据缓冲寄存器（暂存由内存储器读写的一条指令或一个数字，并将不同时间段内读写的数据隔离开来）、程序状态字寄存器（保存由算数指令或逻辑指令运行或执行的结果建立的各种条件码和内容，主要分为状态标识和控制标志，如运算结果进位标志（C），运算结果溢出标志（V）、运算结果为0标志（Z），运算结果为负标志（N），终端标志（I）等等。这些标志通常分别由一位触发器保存，保存了当前指令执行完成之后的状态。通常，一个算数操作产生一个运算结果，而一个逻辑操作则产生一个判决。"),_("br"),t._v("\n3.寄存器：用来保存程序的中间结果，为随后的指令快速提供操作数，避免将结果保存到内存中再从内容中取出的操作。")])]),t._v(" "),_("p",[t._v("4.内部总线：将所有组件连接起来。"),_("br"),t._v("\n寄存器英文全称"),_("br"),t._v(" "),_("img",{attrs:{src:"https://raw.githubusercontent.com/frunoob/images/main/2022/9/7/14/36/33/pic.jpg",alt:"picture"}})]),t._v(" "),_("p",[_("strong",[t._v("定点数和浮点数")]),_("br"),t._v("\n定点数分为定点整数和定点小数，前者规定小数点在最低有效位的后面，后者规定小数点在最高有效位的前面，故小数点不是有效位，所以小数点不占用存储空间。")]),t._v(" "),_("p",[_("strong",[t._v("Cache和主存")]),_("br"),t._v("\n在程序执行的过程中，CPU接收到指令地址是主存中的地址，但是CPU直接访问的是Cache，而不是主存，为此需要一种机制将CPU的访主存此时转换为访Cache地址，而主存地址与Cache地址之间的转换时和主存块与Cache块之间的映射关系紧密联系的。主存和Cache之间的映射是由硬件自动完成的。")]),t._v(" "),_("p",[_("strong",[t._v("直接寻址")]),_("br"),t._v("\n操作数的有效地址直接在指令中给出，不需要地址寄存器。")]),t._v(" "),_("p",[_("strong",[t._v("计算机中CPU访问速度最快的是？")]),_("br"),t._v("\n通用寄存器>Cache>内存>硬盘")]),t._v(" "),_("p",[_("strong",[t._v("补码的意义")]),_("br"),t._v("\n使用补码，可以将符号位和其他位统一处理，同时加减法也可以按照加法来处理，另外两个用补码表示的数相加时，如果高位有进位，则进位被省略。可见采用补码可以简化运算及其电路。")]),t._v(" "),_("p",[t._v("补码表示定点小数，范围是：[-1，(1-2^(-n+1))]，这个范围一共有2^n个数。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("提醒")]),t._v(" "),_("p",[t._v("整数的原码=反码=补码")])]),t._v(" "),_("p",[t._v("机器字长为8位，原码表示的定点整数的范围是 -127（11111111）~ 0 ~ +127（01111111）")]),t._v(" "),_("div",{staticClass:"summary"},[_("p",{staticClass:"title"},[t._v("关于原码")]),_("p",[t._v("使用原码时，0有两种表达方式：（-0）10000000或（+0）000000000")])]),_("p",[t._v("反码表示的定点整数的范围是 -127 (10000000) ~ 0 ~ +127(01111111)")]),t._v(" "),_("div",{staticClass:"summary"},[_("p",{staticClass:"title"},[t._v("关于反码")]),_("p",[t._v("使用反码后，0仍有两种表达方式 +0(00000000)，-0(11111111)"),_("br"),t._v("\n同时，正数的反码等于原码，\n反码的运算法则：\n1.反码运算时，其符号位与数值一起参加运算。"),_("br"),t._v("\n2.反码的符号位相加后，如果有进位出现，则要把它送回到最低位去相加（循环进位）。"),_("br"),t._v("\n3.用反码运算，其运算结果亦为反码。")]),t._v(" "),_("p",[t._v("反码实现了将减法运算使用加法方式来实现。")])]),_("p",[t._v("补码表示的定点整数的范围是 -128 ~ 127, 其中-128代替了原码中的-0，从而使得在补码中仅存在一种0的表达方式。")]),t._v(" "),_("div",{staticClass:"summary"},[_("p",{staticClass:"title"},[t._v("总结")]),_("p",[t._v("二进制中，第n位的值是k ，则该位所代表的十进制值是 (2^n-1)")])])])}),[],!1,null,null,null);v.default=a.exports}}]);