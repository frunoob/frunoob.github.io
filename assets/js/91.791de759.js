(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{296:function(a,t,v){"use strict";v.r(t);var s=v(5),_=Object(s.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"java并发编程面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java并发编程面试题"}},[a._v("#")]),a._v(" Java并发编程面试题")]),a._v(" "),v("h2",{attrs:{id:"什么是进程-什么是线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程-什么是线程"}},[a._v("#")]),a._v(" 什么是进程？什么是线程？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("进程是系统资源分配的基本单位，线程是处理器任务调度的基本单位。")]),a._v(" "),v("p",[a._v("一个进程有多个线程。")])]),v("h2",{attrs:{id:"进程与线程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程的区别"}},[a._v("#")]),a._v(" 进程与线程的区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("进程是系统资源分配的基本单位，线程是处理器任务调度的基本单位。")]),a._v(" "),v("p",[a._v("一个进程有多个线程。")]),a._v(" "),v("p",[a._v("内存分配：进程之间的地址空间和资源是相互独立的，线程之间是共享的。")]),a._v(" "),v("p",[a._v("切换时资源开销：进程切换资源开销大，线程资源开销小。")])]),v("h2",{attrs:{id:"并行与并发的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并行与并发的区别"}},[a._v("#")]),a._v(" 并行与并发的区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("并发：一个处理器处理多个任务，每个任务按照时间片进行轮转执行。")]),a._v(" "),v("p",[a._v("并行：多个处理器同时处理多个任务。")])]),v("h2",{attrs:{id:"多线程的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程的优缺点"}},[a._v("#")]),a._v(" 多线程的优缺点？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("优点："),v("strong",[a._v("充分利用多核CPU的优势")]),a._v("。")]),a._v(" "),v("p",[a._v("缺点：1.死锁 2. 上下文切换频繁影响多线程的执行速度。")])]),v("h2",{attrs:{id:"用户线程和守护线程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户线程和守护线程的区别"}},[a._v("#")]),a._v(" 用户线程和守护线程的区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("调用Thread.setDaemon(bool on)，true就是将线程设置为守护线程，false是用户线程。")]),a._v(" "),v("p",[a._v("一般创建的线程都是用户线程，守护线程是用来服务于用户线程的例如垃圾回收线程。")]),a._v(" "),v("p",[a._v("区别：")]),a._v(" "),v("p",[v("strong",[a._v("用户线程存在java虚拟机不会结束，仅有守护线程的话java虚拟机会结束。")])])]),v("h2",{attrs:{id:"线程死锁是如何产生的-如何避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程死锁是如何产生的-如何避免"}},[a._v("#")]),a._v(" 线程死锁是如何产生的，如何避免？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("必要条件：")]),a._v(" "),v("ol",[v("li",[a._v("互斥条件")]),a._v(" "),v("li",[a._v("请求和保持条件")]),a._v(" "),v("li",[a._v("不剥夺条件")]),a._v(" "),v("li",[a._v("循环等待条件")])]),a._v(" "),v("p",[a._v("解决：")]),a._v(" "),v("ol",[v("li",[a._v("一次性获得全部资源")]),a._v(" "),v("li",[a._v("申请不到资源就主动放弃所持有的资源")]),a._v(" "),v("li",[a._v("顺序执行所有线程")])])]),v("h2",{attrs:{id:"线程的周期和状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的周期和状态"}},[a._v("#")]),a._v(" 线程的周期和状态？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("初始状态，运行状态（就绪状态、运行中状态）、阻塞状态、等待状态、超时等待状态、终止状态。")]),a._v(" "),v("p",[a._v("周期：new一个线程之后，线程进入初始状态，在调用start方法后，线程进入运行状态中的就绪状态，如果获得到cpu就进入到运行中状态，在这个过程中，线程可以主动进入到等待状态直到被其他线程唤醒，或者被动进入到阻塞状态直到获得锁，也可以等待指定时间进入到超时等待状态，如果run方法执行完毕线程就会进入到终止状态。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202202202253927.png",alt:"image-20220220225335814"}})])]),v("h2",{attrs:{id:"创建线程的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建线程的方法"}},[a._v("#")]),a._v(" 创建线程的方法？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ol",[v("li",[a._v("实现Runnable接口")]),a._v(" "),v("li",[a._v("继承Thread类")]),a._v(" "),v("li",[a._v("使用callable创建线程")])])]),v("h2",{attrs:{id:"runnable和callable的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#runnable和callable的区别"}},[a._v("#")]),a._v(" Runnable和Callable的区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("相同点：")]),a._v(" "),v("ul",[v("li",[a._v("都是接口")]),a._v(" "),v("li",[a._v("都需要调用start启动线程")])]),a._v(" "),v("p",[a._v("不同点：")]),a._v(" "),v("ul",[v("li",[a._v("Runnable核心是run方法无返回值，Callable核心是call方法允许返回值。")]),a._v(" "),v("li",[a._v("call()可抛出异常，run()不可以。")])])]),v("h2",{attrs:{id:"线程的run-和start-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的run-和start-区别"}},[a._v("#")]),a._v(" 线程的run()和start()区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ul",[v("li",[a._v("run里面是线程要执行的代码，start是用来启动 一个线程的。")]),a._v(" "),v("li",[a._v("run可以重复调用，start只能调用一次。")])])]),v("h2",{attrs:{id:"为什么要先调用start-而不直接调用run"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要先调用start-而不直接调用run"}},[a._v("#")]),a._v(" 为什么要先调用start()，而不直接调用run()？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("run不会创建一个线程，run()里面是线程要执行的代码，start()才是创建线程。")])]),v("h2",{attrs:{id:"线程的sleep-方法和yield-方法有什么不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的sleep-方法和yield-方法有什么不同"}},[a._v("#")]),a._v(" 线程的sleep()方法和yield()方法有什么不同？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ul",[v("li",[a._v("sleep()方法是使线程暂停指定的时间，不消耗CPU时间片。")]),a._v(" "),v("li",[a._v("sleep()方法会进入到阻塞状态，yield()会进入到就绪状态。")]),a._v(" "),v("li",[a._v("sleep()方法会抛出中断异常，而yield()方法无需抛出异常。")])])]),v("h2",{attrs:{id:"sleep-方法和wait-方法的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sleep-方法和wait-方法的区别"}},[a._v("#")]),a._v(" sleep()方法和wait()方法的区别？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("相同点：")]),a._v(" "),v("ul",[v("li",[a._v("二者都会使线程进入到阻塞状态。")]),a._v(" "),v("li",[a._v("wait和sleep都是可中断方法，被中断后都会收到中断异常。")])]),a._v(" "),v("p",[a._v("不同点：")]),a._v(" "),v("ul",[v("li",[a._v("wait是Object的方法，sleep是Thread方法。")]),a._v(" "),v("li",[a._v("wait必须在同步方法中，sleep不需要。")]),a._v(" "),v("li",[a._v("sleep在短暂休眠后会主动退出阻塞，wait需要其他线程中断才能退出阻塞。")]),a._v(" "),v("li",[a._v("线程执行sleep方法不会释放锁，wait方法会释放锁。")])]),a._v(" "),v("p",[a._v("sleep 方法可以让线程进入 waiting 状态，并且不占用 cpu 资源，但是不会释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态")])]),v("h2",{attrs:{id:"线程通信的方法有那些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程通信的方法有那些"}},[a._v("#")]),a._v(" 线程通信的方法有那些？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ul",[v("li",[a._v("锁与同步")]),a._v(" "),v("li",[a._v("wait()/notify()或notifyALL()")]),a._v(" "),v("li",[a._v("信号量")]),a._v(" "),v("li",[a._v("管道")])])]),v("h2",{attrs:{id:"为什么wait-、notify-、notifyall-、被定义在object类中而不是在thread类中。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么wait-、notify-、notifyall-、被定义在object类中而不是在thread类中。"}},[a._v("#")]),a._v(" 为什么wait()、notify()、notifyAll()、被定义在Object类中而不是在Thread类中。")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需\n要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在\n等待的是哪个锁就不明显了。简单的说，"),v("strong",[a._v("由于wait，notify和notifyAll都是锁级别的操作，所以把他们\n定义在Object类中因为锁属于对象 。")])])]),v("h2",{attrs:{id:"为什么wait-、notify-、notifyall-在同步方法或同步块中调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么wait-、notify-、notifyall-在同步方法或同步块中调用"}},[a._v("#")]),a._v(" 为什么wait()、notify()、notifyAll()在同步方法或同步块中调用？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ol",[v("li",[a._v("只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。")]),a._v(" "),v("li",[a._v("如果你不这么做，你的代码会抛出IllegalMonitorStateException（非法锁状态异常）异常。")]),a._v(" "),v("li",[a._v("还有一个原因是为了避免wait和notify之间产生竞态条件。")])])]),v("h2",{attrs:{id:"为什么thread类中的sleep-和yield-方法是静态的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么thread类中的sleep-和yield-方法是静态的"}},[a._v("#")]),a._v(" 为什么Thread类中的sleep()和yield()方法是静态的？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("这二者都是需要正在执行的线程自身调用的，如果让别的线程调用是无意义的，所以是静态方法。")])]),v("h2",{attrs:{id:"java如何实现两个线程之间的通信和协作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java如何实现两个线程之间的通信和协作"}},[a._v("#")]),a._v(" java如何实现两个线程之间的通信和协作？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("在同步代码块或方法中使用Object类的wait()、notify()、notifyAll()。")])]),v("h2",{attrs:{id:"同步方法和同步块哪个效果好"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步方法和同步块哪个效果好"}},[a._v("#")]),a._v(" 同步方法和同步块哪个效果好？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[v("strong",[a._v("同步块好，它的锁的范围更灵活。")])]),a._v(" "),v("p",[a._v("同步块在需要锁住的代码块中锁住相应的对象，同步方法锁住整个对象。")])]),v("h2",{attrs:{id:"线程同步是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程同步是什么"}},[a._v("#")]),a._v(" 线程同步是什么？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("一个资源只能被一个访问者访问，访问者对资源是有序访问。")])]),v("h2",{attrs:{id:"线程过多会造成什么异常"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程过多会造成什么异常"}},[a._v("#")]),a._v(" 线程过多会造成什么异常？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("ul",[v("li",[a._v("消耗更多的内存和CPU")]),a._v(" "),v("li",[a._v("频繁进行上下文切换")])])]),v("h2",{attrs:{id:"什么是threadlocal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是threadlocal"}},[a._v("#")]),a._v(" 什么是ThreadLocal？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("本地线程变量，ThreadLocal会为变量在每个线程创建一个副本，只能在线程内部访问副本变量，对于其他线程来说是封闭的。")])]),v("h2",{attrs:{id:"什么是线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程池"}},[a._v("#")]),a._v(" 什么是线程池？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("线程池就是一组线程，有任务提交的时候就分配线程，没有任务的时候线程池中的线程就处于等待状态，线程池的作用是为了避免创建和销毁线程时带来的时间消耗。")])]),v("h2",{attrs:{id:"为什么使用线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用线程池"}},[a._v("#")]),a._v(" 为什么使用线程池？")]),a._v(" "),v("details",[v("summary",[a._v("查看答案")]),v("p",[a._v("降低资源消耗，重复利用已创建的线程来避免反复创建和释放线程所带来的资源消耗")]),a._v(" "),v("p",[a._v("提高响应速度，无需创建线程只要在线程池中申请即可立即执行")]),a._v(" "),v("p",[a._v("方便线程的统一管理，避免线程的分配不均")])])])}),[],!1,null,null,null);t.default=_.exports}}]);