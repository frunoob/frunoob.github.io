(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{450:function(a,t,s){"use strict";s.r(t);var r=s(24),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"数据库面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库面试题"}},[a._v("#")]),a._v(" 数据库面试题")]),a._v(" "),s("h2",{attrs:{id:"数据库三大范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库三大范式"}},[a._v("#")]),a._v(" 数据库三大范式")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("第一范式：列不可再分")]),a._v(" "),s("p",[a._v("第二范式： 不存在非主属性部分依赖于候选码")]),a._v(" "),s("p",[a._v("第三范式： 不存在传递依赖")]),a._v(" "),s("p",[a._v("三大范式是一级一级依赖的，高级范式建立在低一级范式之上。")])]),s("h2",{attrs:{id:"什么是索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是索引"}},[a._v("#")]),a._v(" 什么是索引")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("索引是对数据库表的一列或者多列的值进行排序的一种结构，使用索引可以快速访问数据表中的特定信息。")])]),s("h2",{attrs:{id:"索引优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引优缺点"}},[a._v("#")]),a._v(" 索引优缺点")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("优点：1.大大加快数据检索的速度2.加速表与表之间的连接\n缺点：1.建立索引需要占用物理空间2.对数据进行增删的时候要重新维护索引")])]),s("h2",{attrs:{id:"数据库事务是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务是什么"}},[a._v("#")]),a._v(" 数据库事务是什么")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("事务是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体进行提交，要么都执行要么都不执行。")]),a._v(" "),s("p",[s("strong",[a._v("原子性")]),a._v("：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。")]),a._v(" "),s("p",[s("strong",[a._v("一致性")]),a._v("：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。")]),a._v(" "),s("p",[s("strong",[a._v("隔离性")]),a._v("：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。")]),a._v(" "),s("p",[s("strong",[a._v("持久性")]),a._v("：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。")])]),s("h2",{attrs:{id:"sql优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sql优化"}},[a._v("#")]),a._v(" SQL优化")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("ol",[s("li",[a._v("查询语句中不要使用select*")]),a._v(" "),s("li",[a._v("减少子查询，使用关联查询代替(left jion,right jion,inner jion)")]),a._v(" "),s("li",[a._v("减少使用IN或NOT IN，使用exists，not exists活着关联语句代替")]),a._v(" "),s("li",[a._v("or的查询尽量使用union或union all代替")])])]),s("h2",{attrs:{id:"什么是内连接、左外连接、右连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是内连接、左外连接、右连接"}},[a._v("#")]),a._v(" 什么是内连接、左外连接、右连接？")]),a._v(" "),s("h2",{attrs:{id:"like声明中-和-是什么意思"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#like声明中-和-是什么意思"}},[a._v("#")]),a._v(" LIKE声明中%和_是什么意思？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("%：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。\n_：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。")])]),s("h2",{attrs:{id:"如何显示前50行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何显示前50行"}},[a._v("#")]),a._v(" 如何显示前50行")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("SELECT * FROM "),s("table",{attrs:{name:""}},[a._v(" LIMIT 0,50;")])])]),s("h2",{attrs:{id:"索引的底层实现原理和优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引的底层实现原理和优化"}},[a._v("#")]),a._v(" 索引的底层实现原理和优化")]),a._v(" "),s("p",[a._v("B+树，优化的B+树\n主要是在所有的叶子节点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。")]),a._v(" "),s("h2",{attrs:{id:"mysql日志及分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql日志及分类"}},[a._v("#")]),a._v(" MySQL日志及分类")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("日志记录着数据库运行过程中的各种状态信息。")]),a._v(" "),s("p",[a._v("主要包括了错误日志、查询日志、慢查询日志、二进制日志、事务日志几大类。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);