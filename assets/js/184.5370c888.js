(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{387:function(n,r,v){"use strict";v.r(r);var t=v(5),e=Object(t.a)({},(function(){var n=this,r=n.$createElement,v=n._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("h1",{attrs:{id:"中软瑞鑫面试准备"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中软瑞鑫面试准备"}},[n._v("#")]),n._v(" 中软瑞鑫面试准备")]),n._v(" "),v("p",[v("strong",[n._v("自我介绍")]),v("br"),n._v("\n尊敬的面试官您好！\n我叫符琦琦，就读于河北工程大学软件工程专业。")]),n._v(" "),v("p",[n._v("我的意向岗位是java开发，地点是北京。")]),n._v(" "),v("p",[n._v("大学四年主修的课程有java程序设计，数据库原理与应用，Linux操作系统，还有计算机网络等。")]),n._v(" "),v("p",[n._v("本科期间参加了学校计算机协会电脑部，平时协助制作宣传海报。")]),n._v(" "),v("p",[n._v("在校期间多次获得三好学生和奖学金。 我的介绍完毕谢谢。")]),n._v(" "),v("p",[v("strong",[n._v("什么是spring mvc")]),v("br"),n._v("\nSpring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。")]),n._v(" "),v("p",[v("strong",[n._v("spring mvc的工作原理")]),v("br"),n._v("\n（1）用户发送请求至前端控制器DispatcherServlet；"),v("br"),n._v("\n（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；"),v("br"),n._v("\n（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；"),v("br"),n._v("\n（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；"),v("br"),n._v("\n（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；"),v("br"),n._v("\n（6）Handler执行完成返回ModelAndView；"),v("br"),n._v("\n（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；"),v("br"),n._v("\n（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；"),v("br"),n._v("\n（9）ViewResolver解析后返回具体View；"),v("br"),n._v("\n（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）"),v("br"),n._v("\n（11）DispatcherServlet响应用户。")]),n._v(" "),v("p",[v("strong",[n._v("什么是MVC？")]),v("br"),n._v("\nmvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。"),v("br"),n._v("\n模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。"),v("br"),n._v("\n优点是分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。")]),n._v(" "),v("p",[v("strong",[n._v("常见的注解")]),v("br"),n._v("\n@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。"),v("br"),n._v("\n@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。"),v("br"),n._v("\n@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。")]),n._v(" "),v("p",[v("strong",[n._v("spring boot starter的工作原理")]),v("br"),n._v("\n我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter\n在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）")]),n._v(" "),v("p",[v("strong",[n._v("为什么要用SpringBoot")]),v("br"),n._v("\nSpring Boot 优点非常多，如："),v("br"),n._v("\n一、独立运行"),v("br"),n._v("\nSpring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的\njar包就能独立运行，所有的依赖包都在一个jar包内。"),v("br"),n._v("\n二、简化配置"),v("br"),n._v("\nspring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。"),v("br"),n._v("\n三、自动配置"),v("br"),n._v("\nSpring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他\n配置。"),v("br"),n._v("\n四、无代码生成和XML配置"),v("br"),n._v("\nSpring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的\n核心功能之一。"),v("br"),n._v("\n五、应用监控"),v("br"),n._v("\nSpring Boot提供一 系列端点可以监控服务及应用，做健康检测")]),n._v(" "),v("p",[v("strong",[n._v("Spring Boot 的优点")]),v("br"),n._v("\n1、减少开发，测试时间和努力。"),v("br"),n._v("\n2、使用 JavaConfig 有助于避免使用 XML。"),v("br"),n._v("\n3、避免大量的 Maven 导入和各种版本冲突。"),v("br"),n._v("\n4、提供意见发展方法。"),v("br"),n._v("\n5、通过提供默认值快速开始开发。"),v("br"),n._v("\n6、没有单独的 Web 服务器需要。这意味着你不再需要启动 Tomcat，Glassfish或其他任何东西。"),v("br"),n._v("\n7、需要更少的配置 因为没有 web.xml 文件。只需添加用@ Configuration 注释的类，然后添加用@Bean 注释的方法，Spring 将自动加载\n对象并像以前一样对其进行管理。您甚至可以将@Autowired 添加到 bean 方法中，以使 Spring 自动装入需要的依赖关系中。"),v("br"),n._v("\n8、基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应\n用程序属性文件后，Spring 将在（application{environment} .properties）中加载后续的应用程序属性文件。")]),n._v(" "),v("p",[v("strong",[n._v("数据库事务")]),v("br"),n._v("\n事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作， 这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。\n事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性，简称 ACID 属性：\n原子性（Atomicity）")]),n._v(" "),v("ol",[v("li",[n._v("事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执\n行。"),v("br"),n._v("\n一致性（Consistency）")]),n._v(" "),v("li",[n._v("当事务完成时，数据必须处于一致状态。"),v("br"),n._v("\n隔离性（Isolation）")]),n._v(" "),v("li",[n._v("对数据进行修改的所有并发事务是彼此隔离的， 这表明事务必须是独立的，它不应以任何方\n式依赖于或影响其他事务。"),v("br"),n._v("\n永久性（Durability）")]),n._v(" "),v("li",[n._v("事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性")])]),n._v(" "),v("p",[v("strong",[n._v("drop delete、truncate")]),v("br"),n._v("\ndelete,truncate都是删除数据，drop删除结构。"),v("br"),n._v("\ndelete事务提交之后才会生效"),v("br"),n._v("\ntruncate、drop操作之后立即生效不能回滚")]),n._v(" "),v("p",[v("strong",[n._v("视图")]),v("br"),n._v("\n虚拟表，对试图可以增改查，对视图的修改不影响基本表。 获取数据更加方便。")]),n._v(" "),v("p",[v("strong",[n._v("并发事务带来哪些问题")]),v("br"),n._v("\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一\n数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n"),v("strong",[n._v("脏读")]),n._v("（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这\n个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操\n作可能是不正确的。"),v("br"),n._v(" "),v("strong",[n._v("丢失修改")]),n._v("（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第\n二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修。 例如：事务1读取某表中的数据A=20，事务2也读\n取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。"),v("br"),n._v(" "),v("strong",[n._v("不可重复读（Unrepeatableread）")]),n._v(": 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第\n一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的\n数据是不一样的情况，因此称为不可重复读。"),v("br"),n._v(" "),v("strong",[n._v("幻读")]),n._v("（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据\n时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。"),v("br"),n._v(" "),v("strong",[n._v("不可重复读和幻读区别：")]),v("br"),n._v("\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录\n增多或减少了")]),n._v(" "),v("p",[v("strong",[n._v("事务隔离级别")])]),n._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images-1/l4p6udy6ilrgm2.png",alt:""}})]),n._v(" "),v("p",[v("strong",[n._v("sql优化")]),v("br"),n._v("\n查询过程中不使用select*"),v("br"),n._v("\n尽量减少使用子查询，使用关联查询"),v("br"),n._v("\n减少使用in或not in，使用exists，或not exists或关联查询语句替代"),v("br"),n._v("\nor的查询尽量使用union或union all代替（如果没有重复的数据，使用union all更好）"),v("br"),n._v("\n避免在where子句中使用不等于操作符，否则就放弃索引直接全表扫描"),v("br"),n._v("\n避免在where子句中对字段进行null值判断。"),v("br"),n._v("\n在where或order by涉及的列上建立索引"),v("br"),n._v(" "),v("strong",[n._v("大表如何优化")])]),n._v(" "),v("p",[n._v("1.禁止不带审核限制数据范围的查询。"),v("br"),n._v("\n2.读写分离，主库负责写，从库负责读。"),v("br"),n._v("\n3.垂直分区"),v("br"),n._v("\n根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的\n表，甚至放到单独的库做分库。"),v("br"),n._v("\n简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了")]),n._v(" "),v("p",[v("strong",[n._v("MyISAM和InnoDB的区别")]),v("br"),n._v("\nMyISAM：\n不支持事务，但是每次查询都是原子的；\n支持表级锁，即每次操作是对整个表加锁；\n存储表的总行数；\n一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；\n采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引\n基本一致，但是辅索引不用保证唯一性。\nInnoDb：\n支持 ACID 的事务，支持事务的四种隔离级别；\n支持行级锁及外键约束：因此可以支持写并发；")]),n._v(" "),v("p",[v("strong",[n._v("实践中如何优化 MySQL")]),v("br"),n._v("\n最好是按照以下顺序优化：\n1、SQL 语句及索引的优化\n2、数据库表结构的优化\n3、系统配置的优化\n4、硬件的优化")]),n._v(" "),v("p",[v("strong",[n._v("git")])]),n._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images-1/l4p7dpl0jrx4ai.png",alt:""}})])])}),[],!1,null,null,null);r.default=e.exports}}]);