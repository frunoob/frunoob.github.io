(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{423:function(t,a,v){"use strict";v.r(a);var _=v(5),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"软考-计算机系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软考-计算机系统"}},[t._v("#")]),t._v(" 软考-计算机系统")]),t._v(" "),v("blockquote",[v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#计算机系统基础知识"}},[t._v("计算机系统基础知识")]),v("ul",[v("li",[v("a",{attrs:{href:"#原码、反码、补码和移码"}},[t._v("原码、反码、补码和移码")])]),v("li",[v("a",{attrs:{href:"#定点数和浮点数"}},[t._v("定点数和浮点数")])]),v("li",[v("a",{attrs:{href:"#校验码"}},[t._v("校验码")])]),v("li",[v("a",{attrs:{href:"#虚拟存储器"}},[t._v("虚拟存储器")])]),v("li",[v("a",{attrs:{href:"#cpu内部"}},[t._v("CPU内部")])]),v("li",[v("a",{attrs:{href:"#直接寻址"}},[t._v("直接寻址")])]),v("li",[v("a",{attrs:{href:"#计算机中cpu访问速度最快的是"}},[t._v("计算机中CPU访问速度最快的是？")])]),v("li",[v("a",{attrs:{href:"#补码的意义"}},[t._v("补码的意义")])]),v("li",[v("a",{attrs:{href:"#逻辑表达式等价判断"}},[t._v("逻辑表达式等价判断")])]),v("li",[v("a",{attrs:{href:"#关于计算机中的位数"}},[t._v("关于计算机中的位数")])]),v("li",[v("a",{attrs:{href:"#浮点数加减运算"}},[t._v("浮点数加减运算")])])])]),v("li",[v("a",{attrs:{href:"#计算机体系结构"}},[t._v("计算机体系结构")]),v("ul",[v("li",[v("a",{attrs:{href:"#指令系统"}},[t._v("指令系统")])]),v("li",[v("a",{attrs:{href:"#寻址方式"}},[t._v("寻址方式")])])])])])]),v("p")]),t._v(" "),v("h2",{attrs:{id:"计算机系统基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机系统基础知识"}},[t._v("#")]),t._v(" 计算机系统基础知识")]),t._v(" "),v("h3",{attrs:{id:"原码、反码、补码和移码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原码、反码、补码和移码"}},[t._v("#")]),t._v(" 原码、反码、补码和移码")]),t._v(" "),v("p",[t._v("原码： 首位代表数字的正负，其余部分是数字的绝对值。零有两种表示方式。"),v("br"),t._v("\n反码： 首位代表数字的正负，当数字为正数：原码与反码相等；当数字为负数：即符号位为1，其余部分在原码的基础上按位取反。"),v("br"),t._v("\n补码： 同样，最高位代表符号位，0为正，1为负。为正数时，原码=反码=补码；为负数时，补码等于反码+1。"),v("br"),t._v("\n移码： 在数字X的基础上增加一个偏移量，常常用于表示浮点数中的阶码。")]),t._v(" "),v("div",{staticClass:"custom-block danger"},[v("p",{staticClass:"custom-block-title"},[t._v("备忘")]),t._v(" "),v("p",[t._v("还是不太懂移码到底是怎么用的")])]),t._v(" "),v("h3",{attrs:{id:"定点数和浮点数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定点数和浮点数"}},[t._v("#")]),t._v(" 定点数和浮点数")]),t._v(" "),v("p",[t._v("定点数包括定点整数（纯整数，小数点在最低有效数值之后）和定点小数（纯小数，小数点在最高有效数值之前）"),v("br"),t._v("\n浮点数就是小数点位置不固定的数，它能够表示更大范围的数字。浮点数表示法中，"),v("code",[t._v("阶码")]),t._v("通常为带符号的纯整数，"),v("code",[t._v("尾数")]),t._v("是带符号的纯小数。"),v("strong",[t._v("尾数决定精度，阶码(阶)决定范围")]),v("br"),t._v("\n浮点数的表示格式如图： | 阶符 | 阶码 | 数符 | 尾数 |"),v("br"),t._v("\n浮点数通常表示为： "),v("code",[t._v("N = M * R^E")]),v("br"),t._v("\nM为尾数，R为基数，E为阶码。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("工业标准 IEEE 754")]),t._v(" "),v("p",[t._v("IEEE754是由IEEE（电气电子工程师学会）制定的有关浮点数的工业标准，该标准的表示形式为: (-1)^s2^E(b_0b_1b_2...b_(p-1))"),v("br"),t._v("\n其中(-1)^s表示该浮点数的数符， 当s为0时为正数，1时为负数。E为指数（阶码），用移码表示。其余为尾数。长度为P，用原码表示。")])]),t._v(" "),v("h3",{attrs:{id:"校验码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#校验码"}},[t._v("#")]),t._v(" 校验码")]),t._v(" "),v("p",[t._v("计算机系统运行时，各个部件之间要进行数据交换，有两种方式：提高电路的可靠性 和 提高代码的校验能力，包括查错和纠错。通常使用校验码的方式来研策传送到数据是否出错。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("码距")]),t._v(" "),v("p",[t._v("所谓码距指的是一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。")])]),t._v(" "),v("div",{staticClass:"summary"},[v("p",{staticClass:"title"},[t._v("三种校验方式")]),v("ol",[v("li",[v("p",[t._v("奇偶校验")])]),t._v(" "),v("li",[v("p",[t._v("海明码"),v("br"),t._v("\n利用多组数位的"),v("strong",[t._v("奇偶性来检错和校验")]),t._v("\n构成方法是：在数据位之间插入k个校验位，通过扩大码距来实现检错和纠错。"),v("br"),t._v("\nn和k满足关系："),v("code",[t._v("2^k -1 >= n+k")]),t._v(" ,取能满足不等式的最小值即可。")])]),t._v(" "),v("li",[v("p",[t._v("循环冗余校验码")])])]),t._v(" "),v("p",[t._v("循环冗余校验码由两个部分组成，左面为信息码，右面为校验码。如信息码占k位，则校验码占"),v("code",[t._v("n-k")]),t._v("位。n位CRC码的字长，所以又称为(n,k)码。校验码是由信息码产生的，校验码位数越长，改代码的校验能力越强，在求CRC编码时，采用的是模2运算，其加减运算是按位运算，不会发生借位或者错位。")])]),v("h3",{attrs:{id:"虚拟存储器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟存储器"}},[t._v("#")]),t._v(" 虚拟存储器")]),t._v(" "),v("p",[t._v("虚拟存储器由"),v("code",[t._v("主存-辅存")]),t._v("两级存储器组成。  虚拟存储器的作用是解决内存不足的问题，将硬盘存储当作内存来使用。")]),t._v(" "),v("h3",{attrs:{id:"cpu内部"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu内部"}},[t._v("#")]),t._v(" CPU内部")]),t._v(" "),v("ol",[v("li",[t._v("控制器： 协调和指挥整个计算机系统的操作，是发布命令的决策机构，保证指令的正确执行，并且能够处理异常事件。"),v("br"),t._v("\n控制器由指令寄存器(IR)，程序计数器(PC)，地址寄存器(AR)，指令译码器(ID)组成。指令寄存器将从内存储器中取到缓冲寄存器中的指令暂存起来，然后指令译码器根据IR的内容将指令中的操作码进行分析，产生各种微操作指令，执行指令时，PC永远保存着下一条指令的地址，每执行一条指令时，CPU都将自动修改PC的内容，以便PC中保存的总是将要执行的下一条指令的地址。地址寄存器用于保存当前CPU访问的内存单元的地址，")]),t._v(" "),v("li",[t._v("运算器：负责算数运算和逻辑运算"),v("br"),t._v("\n运算器由四个部分组成，算术逻辑单元(负责算数和逻辑运算)、累加寄存器（简称累加器，是一个通用寄存器，其功能是当运算器的算术逻辑单元执行算数或逻辑运算时，提供工作区）、数据缓冲寄存器（暂存由内存储器读写的一条指令或一个数字，并将不同时间段内读写的数据隔离开来）、程序状态字寄存器（保存由算数指令或逻辑指令运行或执行的结果建立的各种条件码和内容，主要分为状态标识和控制标志，如运算结果进位标志（C），运算结果溢出标志（V）、运算结果为0标志（Z），运算结果为负标志（N），终端标志（I）等等。这些标志通常分别由一位触发器保存，保存了当前指令执行完成之后的状态。通常，一个算数操作产生一个运算结果，而一个逻辑操作则产生一个判决。"),v("br"),t._v("\n3.寄存器：用来保存程序的中间结果，为随后的指令快速提供操作数，避免将结果保存到内存中再从内容中取出的操作。")])]),t._v(" "),v("p",[t._v("4.内部总线：将所有组件连接起来。"),v("br"),t._v("\n寄存器英文全称"),v("br"),t._v(" "),v("img",{attrs:{src:"https://raw.githubusercontent.com/frunoob/images/main/2022/9/7/14/36/33/pic.jpg",alt:"picture"}}),t._v(" "),v("strong",[t._v("一些关于CPU的叙述")]),v("br"),t._v(" "),v("img",{attrs:{src:"https://raw.githubusercontent.com/frunoob/images/main/2022/9/8/11/25/34/pic.jpg",alt:"picture"}}),v("br"),t._v("\nCPU产生的每条指令的操作信息并将操作信号送往相应的不见进行控制。"),v("br"),t._v("\n程序计数器（PC）具有寄存信息和计数两个功能，又称为指令计数器。在程序执行之前，将指令地址送到PC，这个指令地址是在程序写入到内存中时确定的，当执行当前指令的时候，CPU自动修改PC内容，顺序执行时PC直接+1，当是转移指令时，后继指令的地址为当前指令地址加上一个向前或者向后的位移量得到。因此，PC所寄存的信息仅仅局限于指令地址，计数仅仅局限于对于指令地址的计数，并没有对算数或逻辑运算结果存储的功能。"),v("br"),t._v("\n(累加器)通用寄存器有临时存储计算/逻辑运算结果的功能。")]),t._v(" "),v("p",[v("strong",[t._v("定点数和浮点数")]),v("br"),t._v("\n定点数分为定点整数和定点小数，前者规定小数点在最低有效位的后面，后者规定小数点在最高有效位的前面，故小数点不是有效位，所以小数点不占用存储空间。")]),t._v(" "),v("p",[v("strong",[t._v("Cache和主存")]),v("br"),t._v("\n在程序执行的过程中，CPU接收到指令地址是主存中的地址，但是CPU直接访问的是Cache，而不是主存，为此需要一种机制将CPU的访主存此时转换为访Cache地址，而主存地址与Cache地址之间的转换时和主存块与Cache块之间的映射关系紧密联系的。主存和Cache之间的映射是由硬件自动完成的。")]),t._v(" "),v("h3",{attrs:{id:"直接寻址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接寻址"}},[t._v("#")]),t._v(" 直接寻址")]),t._v(" "),v("p",[t._v("操作数的有效地址直接在指令中给出，不需要地址寄存器。")]),t._v(" "),v("h3",{attrs:{id:"计算机中cpu访问速度最快的是"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机中cpu访问速度最快的是"}},[t._v("#")]),t._v(" 计算机中CPU访问速度最快的是？")]),t._v(" "),v("p",[t._v("通用寄存器>Cache>内存>硬盘")]),t._v(" "),v("h3",{attrs:{id:"补码的意义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补码的意义"}},[t._v("#")]),t._v(" 补码的意义")]),t._v(" "),v("p",[t._v("使用补码，可以将符号位和其他位统一处理，同时加减法也可以按照加法来处理，另外两个用补码表示的数相加时，如果高位有进位，则进位被省略。可见采用补码可以简化运算及其电路。")]),t._v(" "),v("p",[t._v("补码表示定点小数，范围是：[-1，(1-2^(-n+1))]，这个范围一共有2^n个数。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提醒")]),t._v(" "),v("p",[t._v("整数的原码=反码=补码")])]),t._v(" "),v("p",[t._v("机器字长为8位，原码表示的定点整数的范围是 -127（11111111）~ 0 ~ +127（01111111）")]),t._v(" "),v("div",{staticClass:"summary"},[v("p",{staticClass:"title"},[t._v("关于原码")]),v("p",[t._v("使用原码时，0有两种表达方式：（-0）10000000或（+0）000000000")])]),v("p",[t._v("反码表示的定点整数的范围是 -127 (10000000) ~ 0 ~ +127(01111111)")]),t._v(" "),v("div",{staticClass:"summary"},[v("p",{staticClass:"title"},[t._v("关于反码")]),v("p",[t._v("使用反码后，0仍有两种表达方式 +0(00000000)，-0(11111111)"),v("br"),t._v("\n同时，正数的反码等于原码，\n反码的运算法则：\n1.反码运算时，其符号位与数值一起参加运算。"),v("br"),t._v("\n2.反码的符号位相加后，如果有进位出现，则要把它送回到最低位去相加（循环进位）。"),v("br"),t._v("\n3.用反码运算，其运算结果亦为反码。")]),t._v(" "),v("p",[t._v("反码实现了将减法运算使用加法方式来实现。")])]),v("p",[t._v("补码表示的定点整数的范围是 -128 ~ 127, 其中-128代替了原码中的-0，从而使得在补码中仅存在一种0的表达方式。")]),t._v(" "),v("div",{staticClass:"summary"},[v("p",{staticClass:"title"},[t._v("总结")]),v("p",[t._v("二进制中，第n位的值是k ，则该位所代表的十进制值是 (2^n-1)")])]),v("h3",{attrs:{id:"逻辑表达式等价判断"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逻辑表达式等价判断"}},[t._v("#")]),t._v(" 逻辑表达式等价判断")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/frunoob/images/main/2022/9/8/10/40/51/pic.jpg",alt:"picture"}})]),t._v(" "),v("p",[t._v("使用举例子找到特殊值来排除错误选项。")]),t._v(" "),v("h3",{attrs:{id:"关于计算机中的位数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于计算机中的位数"}},[t._v("#")]),t._v(" 关于计算机中的位数")]),t._v(" "),v("p",[t._v("64位的微处理器可以同时对64位数据进行运算，但不能说它的速度是32位微处理器的2倍。"),v("br"),t._v(" "),v("strong",[t._v("数据总线的宽度、CPU能同时进行运算的位数、通用寄存器的位数都与CPU的位数相同")]),v("br"),t._v("\n地址总线的宽度则不一定。"),v("br"),t._v(" "),v("strong",[t._v("指令寄存器的位数取决于什么？")]),v("br"),t._v(" "),v("strong",[t._v("位数")]),t._v("：也叫“ 字长 ”，是指处理器一次运算所能处理的 二进制数 的位数。. 计算机字长有8位、16位、32位、64位之分。. 我们一般称8位（bit）为一个字节（Byte）。"),v("br"),t._v("\n指令寄存器的位数取决于指令长度，指令长度是变化的。")]),t._v(" "),v("h3",{attrs:{id:"浮点数加减运算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浮点数加减运算"}},[t._v("#")]),t._v(" 浮点数加减运算")]),t._v(" "),v("p",[t._v("在进行浮点数计算时需要进行对阶操作，"),v("strong",[t._v("小阶向大阶看齐")])]),t._v(" "),v("h2",{attrs:{id:"计算机体系结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机体系结构"}},[t._v("#")]),t._v(" 计算机体系结构")]),t._v(" "),v("h3",{attrs:{id:"指令系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令系统"}},[t._v("#")]),t._v(" 指令系统")]),t._v(" "),v("p",[t._v("指令系统指的是一个CPU能够处理的全部指令的集合，是一个CPU的根本属性。一个指令一般包括两个部分"),v("strong",[t._v("操作码")]),t._v("和"),v("strong",[t._v("地址码")]),t._v("。操作码指明操作的类型，地址码主要指明操作数及运算结果存放的地址。")]),t._v(" "),v("h3",{attrs:{id:"寻址方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#寻址方式"}},[t._v("#")]),t._v(" 寻址方式")]),t._v(" "),v("p",[t._v("表示指令中"),v("strong",[t._v("操作数")]),t._v("所在的方法称为寻址方式。常见的寻址方式有以下几种。"),v("br"),t._v("\n（1） 立即寻址：操作数作为指令的一部分而直接写在指令中，这种操作数称为立即数。"),v("br"),t._v("\n（2）寄存器寻址：指令所要的操作数已存储在某寄存器中，或把目标操作数寄存器。"),v("br"),t._v("\n（3）直接寻址：指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址。"),v("br"),t._v("\n（4) 寄存器间接寻址：操作数在存储器中，操作数的有效地址用SI DI BX 和BP这4个寄存器之一来指定。"),v("br"),t._v("\n（5）寄存器相对寻址： 操作数在存储器中，其有效地址是一个基址寄存器（BX、BP）或变址寄存器（SI、DI）的内容之和。")])])}),[],!1,null,null,null);a.default=s.exports}}]);