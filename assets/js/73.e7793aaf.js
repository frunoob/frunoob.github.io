(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{277:function(a,t,s){"use strict";s.r(t);var r=s(5),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"集合基础面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合基础面试题"}},[a._v("#")]),a._v(" 集合基础面试题")]),a._v(" "),s("blockquote",[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul")]),s("p")]),a._v(" "),s("h4",{attrs:{id:"_1-请描述一下你对集合的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-请描述一下你对集合的理解"}},[a._v("#")]),a._v(" 1. 请描述一下你对集合的理解？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),a._v(" "),s("pre",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',"margin-top":"0px","margin-bottom":"1rem",overflow:"visible",display:"block",color:"rgb(33, 37, 41)",position:"relative","word-break":"break-all","border-radius":"4px","white-space":"pre-wrap"}},[a._v("  集合代表一组相同类型的对象，称之为元素。集合长度可变。\n集合分两大类：继承了 Collection 接口的 List 和 Set 子接口，还有 Map 接口。\n")])]),s("h4",{attrs:{id:"_2-hashmap-和-hashtable-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-hashmap-和-hashtable-的区别"}},[a._v("#")]),a._v(" 2. HashMap 和 Hashtable 的区别？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("p",[a._v("他们都实现了 Map 接口，他们二者hash算法大概一样，性能差距不大。\n主要区别在于：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("HashMap 可以有null， Hashtable ：key和value都不允许为null。")])]),a._v(" "),s("li",[s("p",[a._v("Hashtable 的方法是 Synchronize 的，而 HashMap 不是。")])])]),a._v(" "),s("p",[a._v("3.父类不同，HashMap继承AbstractMap类，Hashtable继承Dictionary类。")])]),s("h4",{attrs:{id:"_3-list-和-map-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-list-和-map-的区别"}},[a._v("#")]),a._v(" 3. List 和 Map 的区别？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("p",[a._v("一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List 中存储的数据是有顺序，并且允许重复；Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。")])]),s("h4",{attrs:{id:"_4-list、map、set-三个接口-存取元素时-各有什么特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-list、map、set-三个接口-存取元素时-各有什么特点"}},[a._v("#")]),a._v(" 4. List、Map、Set 三个接口，存取元素时，各有什么特点？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("p",[a._v("List:存元素时add，元素可以重复且元素有序；取元素时可以使用get方法也可以使用iterator迭代器\nSet：存元素时add，元素不可以重复；取元素时无法取指定位置的元素只能使用Iterator接口获取全部元素再逐一遍历"),s("br"),a._v("\nMap接口：存元素时使用put方法每次要存储一对key/value，并且key不能重复，value可以重复；取元素时使用get方法获取指定key对应的value，也可以获取所有key的集合、所有value的集合、所有键值对的集合。")])]),s("h4",{attrs:{id:"_5-说出-arraylist-vector-linkedlist-的存储性能和特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-说出-arraylist-vector-linkedlist-的存储性能和特性"}},[a._v("#")]),a._v(" 5. 说出 ArrayList，Vector， LinkedList 的存储性能和特性 ？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("p",[a._v("ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\nLinkedList 也是线程不安全的，LinkedList 提供了一些方法，使得 LinkedList 可以被当作堆栈和队列来使用。")])]),s("h4",{attrs:{id:"_6-去掉一个-vector-集合中重复的元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-去掉一个-vector-集合中重复的元素"}},[a._v("#")]),a._v(" 6. 去掉一个 Vector 集合中重复的元素？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("p",[s("code",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',color:"rgb(232, 62, 140)","overflow-wrap":"break-word"}},[a._v("Vector newVector = new Vector(); For (int i=0;i<vector.size();i++) { Object obj = vector.get(i); if(!newVector.contains(obj); newVector.add(obj); }")]),s("pre",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',"margin-top":"0px","margin-bottom":"1rem",overflow:"visible",display:"block",color:"rgb(33, 37, 41)",position:"relative","word-break":"break-all","border-radius":"4px","white-space":"pre-wrap"}},[a._v(" 还有一种简单的方式，HashSet set = new HashSet(vector); ")])])]),s("h4",{attrs:{id:"_7-collection-和-collections-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-collection-和-collections-的区别"}},[a._v("#")]),a._v(" 7. Collection 和 Collections 的区别？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),a._v(" "),s("pre",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',"margin-top":"0px","margin-bottom":"1rem",overflow:"visible",display:"block",color:"rgb(33, 37, 41)",position:"relative","word-break":"break-all","border-radius":"4px","white-space":"pre-wrap"}},[a._v("  Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.\n  Collections 是针对集合类的一个工具类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。\n    ")])]),s("h4",{attrs:{id:"_8-set-里的元素是不能重复的-那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-set-里的元素是不能重复的-那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别"}},[a._v("#")]),a._v(" 8. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),a._v(" "),s("pre",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',"margin-top":"0px","margin-bottom":"1rem",overflow:"visible",display:"block",color:"rgb(33, 37, 41)",position:"relative","word-break":"break-all","border-radius":"4px","white-space":"pre-wrap"}},[a._v("  Set 里的元素是不能重复的，元素重复与否是使用 equals() 方法进行判断的。\n  equals()和==的区别：略。\n    ")])]),s("h4",{attrs:{id:"_9-你所知道的集合类都有哪些-主要方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-你所知道的集合类都有哪些-主要方法"}},[a._v("#")]),a._v(" 9. 你所知道的集合类都有哪些？主要方法？")]),a._v(" "),s("details",[s("summary",[a._v("答案")]),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("（1）List：实现类：ArrayList和Vector。主要方法：add,remove,contains,get等\n（2）Set：实现类：Hashset和TreeSet。主要方法：add，remove，contains等\n（3）Map：实现类：HashMap和TreeMap。主要方法：get，put，remove，contains等\n")])])])]),s("h4",{attrs:{id:"_10-两个对象值相同-x-equals-y-true-但却可有不同的-hash-code-这句话对不对"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-两个对象值相同-x-equals-y-true-但却可有不同的-hash-code-这句话对不对"}},[a._v("#")]),a._v(" 10. 两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对？")]),a._v(" "),s("details",[s("summary",[a._v("answer")]),s("pre",{staticStyle:{"box-sizing":"border-box","font-size":"14px","font-family":'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',"margin-top":"0px","margin-bottom":"1rem",overflow:"visible",display:"block",color:"rgb(33, 37, 41)",position:"relative","word-break":"break-all","border-radius":"4px","white-space":"pre-wrap"}},[a._v("  不对，因为java对于equals和hashcode的规定是：\n1) 对象相等则hashCode一定相等；\n2) hashCode相等对象未必相等。\n")])]),s("h4",{attrs:{id:"_11-线程安全的集合类有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-线程安全的集合类有哪些"}},[a._v("#")]),a._v(" 11.线程安全的集合类有哪些？")]),a._v(" "),s("details",[s("summary",[a._v("answer")]),s("p",[a._v("vector，HashTable")])]),s("h4",{attrs:{id:"_12-array和arraylist的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-array和arraylist的区别"}},[a._v("#")]),a._v(" 12.Array和ArrayList的区别？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("Array可以有基本数据类型和对象，ArrayList里面必须是对象；\nArray数组长度固定，ArrayList长度可变。")])]),s("h4",{attrs:{id:"_13-comparable和comparator的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-comparable和comparator的区别"}},[a._v("#")]),a._v(" 13.comparable和comparator的区别？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("comparable是一个内部比较器，用于比较两个类的大小，很多包装类已经实现了该接口，如果对内部的排序规则不满意可以使用Comparator来进行自定义规则的比较，所以灵活性上Conparator更优。")])]),s("h4",{attrs:{id:"_14-list集合遍历方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-list集合遍历方式"}},[a._v("#")]),a._v(" 14.List集合遍历方式？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("for循环"),s("br"),a._v("\nfor each循环\niterator遍历")]),a._v(" "),s("p",[a._v("set只有后两种方式来遍历")])]),s("h4",{attrs:{id:"_15-arraylist的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-arraylist的扩容机制"}},[a._v("#")]),a._v(" 15.ArrayList的扩容机制")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("初始为10 每次扩容1.5倍")])]),s("h4",{attrs:{id:"_16-arraylist和vector的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-arraylist和vector的区别"}},[a._v("#")]),a._v(" 16.ArrayList和Vector的区别？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("相同点：1.都实现了List接口2.底层数据结构都是数组"),s("br"),a._v("\n不同点：1.线程安全：前者不安全后者安全2.性能上后者由于加了线程安全锁 所以vector性能不如ArrayList3.ArrayList每次扩容1.5倍，Vector每次扩容2倍。")])]),s("h4",{attrs:{id:"_17-arraylist和linkedlist区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-arraylist和linkedlist区别"}},[a._v("#")]),a._v(" 17.ArrayList和LinkedList区别？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("ol",[s("li",[a._v("底层实现：前者是数组后者是双向链表")]),a._v(" "),s("li",[a._v("内存占用：前者需要扩容1.5倍，所以会有空间浪费。后者每个元素要存放直接前驱、直接后继和数据，所以每个元素要占用更多的空间。")]),a._v(" "),s("li",[a._v("都不是线程安全的")]),a._v(" "),s("li",[a._v("前者适合多读少增删的场景，后者适合多增删少读的场景。")])])]),s("h4",{attrs:{id:"_18-arraylist、vector、linklist存储性能和特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-arraylist、vector、linklist存储性能和特性"}},[a._v("#")]),a._v(" 18.ArrayList、Vector、LinkList存储性能和特性")]),a._v(" "),s("h4",{attrs:{id:"hashset的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset的实现原理"}},[a._v("#")]),a._v(" HashSet的实现原理")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("HashSet的底层是一个HashMap，初始容量为16，负载因子为0.75，HashSet的值存放于HashMap的key上。")])]),s("h4",{attrs:{id:"hashset如何检查重复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset如何检查重复"}},[a._v("#")]),a._v(" HashSet如何检查重复？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("先计算key的hashcode值，通过计算算出元素的位置，如果hash冲突，则由equals方法判断key是否重复。")])]),s("h4",{attrs:{id:"hashmap在1-7和1-8中的不同-底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap在1-7和1-8中的不同-底层实现"}},[a._v("#")]),a._v(" HashMap在1.7和1.8中的不同？底层实现？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("1.7: 数组+链表"),s("br"),a._v("\n1.8：数组+链表   链表长度>8时转化为红黑树")])]),s("h4",{attrs:{id:"hashmap的put方法的流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的put方法的流程"}},[a._v("#")]),a._v(" HashMap的put方法的流程")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202202191542130.jpg",alt:""}})])]),s("h4",{attrs:{id:"hashmap的扩容如何实现的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的扩容如何实现的"}},[a._v("#")]),a._v(" HashMap的扩容如何实现的？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("初始值是16，负载因子是0.75，阈值为容量x负载因子。"),s("br"),a._v("\n当元素数量超过阈值时就是触发扩容机制，每次扩容两倍。")])]),s("h4",{attrs:{id:"hashmap为啥选择0-75作为负载因子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap为啥选择0-75作为负载因子"}},[a._v("#")]),a._v(" HashMap为啥选择0.75作为负载因子？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("空间利用和查询成本的一个折中。过低导致空间利用率提高但是hash冲突概率增加，过高造成空间浪费。")])]),s("h4",{attrs:{id:"链表转化为红黑树的阈值为何为8-为何不一开始就是红黑树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表转化为红黑树的阈值为何为8-为何不一开始就是红黑树"}},[a._v("#")]),a._v(" 链表转化为红黑树的阈值为何为8？为何不一开始就是红黑树？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("红黑树的节点空间是普通链表节点的两倍，但是查找的时间复杂度低，当节点数量特别多的时候红黑树的优点才能体现出来。 链表转化为红黑树除了链表长度大于8还要HashMap中的数组长度大于64。")])]),s("h4",{attrs:{id:"hashmap如何解决hash冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap如何解决hash冲突"}},[a._v("#")]),a._v(" HashMap如何解决Hash冲突？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("拉链法：当产生hash冲突就用链表的形式将节点挂在数组后面。"),s("br"),a._v("\nhash函数：多次使用hash函数来降低hash冲突的概率。"),s("br"),a._v("\n红黑树：当链表长度大于8的时候将链表转化为红黑树。")])]),s("h4",{attrs:{id:"能否使用任何类作为map的key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#能否使用任何类作为map的key"}},[a._v("#")]),a._v(" 能否使用任何类作为Map的Key？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("可以，但需要注意：如果该类重写了equals方法就必须重写hashcode方法并且最好定义key类是不可变的，这样可以对key的hashcode值进行缓存提高效率。")])]),s("h4",{attrs:{id:"为什么hashmap中的string、integer这样的包装类适合作为key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么hashmap中的string、integer这样的包装类适合作为key"}},[a._v("#")]),a._v(" 为什么HashMap中的String、Integer这样的包装类适合作为Key？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("首先这些包装类都是final修饰的，是不可变的，保证了key的hashcode值的不变性。"),s("br"),a._v("\n这些类已经重写了equals方法和hashcode方法。")])]),s("h4",{attrs:{id:"如果object作为hashmap的key-应该怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果object作为hashmap的key-应该怎么办"}},[a._v("#")]),a._v(" 如果Object作为HashMap的Key，应该怎么办？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("重写hashcode方法，需要计算hash值来确定位置"),s("br"),a._v("\n重写equals方法来判断key是否重复")])]),s("h4",{attrs:{id:"concurrenthashmap底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap底层实现"}},[a._v("#")]),a._v(" ConCurrentHashMap底层实现？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("理解：HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁。那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。"),s("br"),a._v("\n总结：1.7采用分段锁，同时锁住多个节点，而1.8则锁的是节点，节点锁是一种粒度更小的锁，减少了锁的竞争，提高了ConsurrentHashMap的并发能力。"),s("br"),a._v("\n1.7底层是一个segment数组和多个HashEntry数组+链表，1.8是数组+链表+红黑树类似于HashMap底层实现")])]),s("h4",{attrs:{id:"hashtable的底层实现知道吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashtable的底层实现知道吗"}},[a._v("#")]),a._v(" hashTable的底层实现知道吗？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("底层是数组+链表，链表主要是解决hash冲突，整个数组都是synchronized修饰的，所以HashTable是线程安全，锁的粒度大，锁竞争大，效率低。")])]),s("h4",{attrs:{id:"hashmap、concurrenthashmap、hashtable的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap、concurrenthashmap、hashtable的区别"}},[a._v("#")]),a._v(" HashMap、ConcurrentHashMap、HashTable的区别")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/frunoob/images/202202191635121.png",alt:""}})])]),s("h4",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")])]),a._v(" "),s("h4",{attrs:{id:"stringbuffer和stringbuilder的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stringbuffer和stringbuilder的区别"}},[a._v("#")]),a._v(" StringBuffer和StringBuilder的区别？")]),a._v(" "),s("details",[s("summary",[a._v("查看答案")]),s("p",[a._v("前者线程安全，是同步的，后者不安全是不同步的")])])])}),[],!1,null,null,null);t.default=e.exports}}]);