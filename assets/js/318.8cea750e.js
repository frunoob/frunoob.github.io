(window.webpackJsonp=window.webpackJsonp||[]).push([[318],{521:function(t,a,e){"use strict";e.r(a);var r=e(5),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-spring-boot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-spring-boot"}},[t._v("#")]),t._v(" react|spring boot")]),t._v(" "),e("p",[t._v("https://spring.io/guides/tutorials/react-and-spring-data-rest/")]),t._v(" "),e("h2",{attrs:{id:"immutability-react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#immutability-react"}},[t._v("#")]),t._v(" immutability|react")]),t._v(" "),e("p",[t._v("底层数据不变性。"),e("br"),t._v("\n我们可以直接对原数据进行修改，也可以生成原数据的副本，对副本进行修改，最后将整个副本覆盖原数据，那么，这么做的意义是？")]),t._v(" "),e("p",[t._v("首先我们要知道，每当修改属性state时（前提是使用useState函数声明并初始化属性），react都是重新渲染该属性所在组件。")]),t._v(" "),e("p",[t._v("react的setState是异步的，在当前已经执行的代码里面可能不会立即生效，虽然渲染视图了，但是代码里调用这个变量，他仍然是原来的值。")]),t._v(" "),e("p",[t._v("这时，就要创建副本来记录值的变化，并能够被获取得到。")]),t._v(" "),e("p",[t._v("html tag 写在 js中就叫做   jsx javascript xml")]),t._v(" "),e("h2",{attrs:{id:"nextjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nextjs"}},[t._v("#")]),t._v(" nextjs")]),t._v(" "),e("p",[t._v("最新版本的next框架不再使用pages作为路由目录，而是改用app路由  "),e("a",{attrs:{href:"https://nextjs.org/docs/getting-started/installation",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);