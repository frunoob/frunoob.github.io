<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类和对象面试题 | FRUNOOB</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/apple-touch-icon.png?v=1.0.0">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png?v=1.0.0">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png?v=1.0.0">
    <link rel="manifest" href="/assets/img/site.webmanifest?v=1.0.0">
    <link rel="mask-icon" href="/assets/img/safari-pinned-tab.svg?v=1.0.0" color="#5bbad5">
    <link rel="shortcut icon" href="/assets/img/favicon.ico?v=1.0.0">
    <script src="/assets/prism.js"></script>
    <link rel="stylesheet" href="/assets/prism.css">
    <meta name="description" content="">
    <meta name="theme-color" content="#fffff8">
    <meta name="apple-mobile-web-app-title" content="F的博客">
    <meta name="application-name" content="F的博客">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="msapplication-config" content="/assets/img/browserconfig.xml?v=1.0.0">
    <link rel="preload" href="/assets/css/0.styles.a54d33b6.css" as="style"><link rel="preload" href="/assets/js/app.42784d71.js" as="script"><link rel="preload" href="/assets/js/10.5f3a76f7.js" as="script"><link rel="preload" href="/assets/js/3.9a2ec5a7.js" as="script"><link rel="preload" href="/assets/js/7.f44fb539.js" as="script"><link rel="preload" href="/assets/js/34.b96ec4f2.js" as="script"><link rel="preload" href="/assets/js/11.bea036dd.js" as="script"><link rel="prefetch" href="/assets/js/12.a2ce7019.js"><link rel="prefetch" href="/assets/js/13.7879ac45.js"><link rel="prefetch" href="/assets/js/14.25860ca4.js"><link rel="prefetch" href="/assets/js/15.3b3608ae.js"><link rel="prefetch" href="/assets/js/16.31be3896.js"><link rel="prefetch" href="/assets/js/17.ca55e837.js"><link rel="prefetch" href="/assets/js/18.9567031f.js"><link rel="prefetch" href="/assets/js/19.5fa5cf03.js"><link rel="prefetch" href="/assets/js/2.13b0f1ec.js"><link rel="prefetch" href="/assets/js/20.a9348756.js"><link rel="prefetch" href="/assets/js/21.e823b40f.js"><link rel="prefetch" href="/assets/js/22.21b18d3f.js"><link rel="prefetch" href="/assets/js/23.bfb71abc.js"><link rel="prefetch" href="/assets/js/24.a7505efd.js"><link rel="prefetch" href="/assets/js/25.57d3b973.js"><link rel="prefetch" href="/assets/js/26.fc49ffc8.js"><link rel="prefetch" href="/assets/js/27.eb05f41b.js"><link rel="prefetch" href="/assets/js/28.08da7ebf.js"><link rel="prefetch" href="/assets/js/29.4d61af18.js"><link rel="prefetch" href="/assets/js/30.6629dba4.js"><link rel="prefetch" href="/assets/js/31.719a532c.js"><link rel="prefetch" href="/assets/js/32.1121664c.js"><link rel="prefetch" href="/assets/js/33.675d0b94.js"><link rel="prefetch" href="/assets/js/35.8f2dca01.js"><link rel="prefetch" href="/assets/js/36.335b14da.js"><link rel="prefetch" href="/assets/js/37.ad811147.js"><link rel="prefetch" href="/assets/js/38.ed90ee99.js"><link rel="prefetch" href="/assets/js/39.121700ec.js"><link rel="prefetch" href="/assets/js/4.ea027014.js"><link rel="prefetch" href="/assets/js/40.b3da8af0.js"><link rel="prefetch" href="/assets/js/41.4b86bcfe.js"><link rel="prefetch" href="/assets/js/42.63428771.js"><link rel="prefetch" href="/assets/js/43.ec39a6c2.js"><link rel="prefetch" href="/assets/js/44.957fa1fe.js"><link rel="prefetch" href="/assets/js/45.dc637e07.js"><link rel="prefetch" href="/assets/js/46.457be4b4.js"><link rel="prefetch" href="/assets/js/47.bd39253b.js"><link rel="prefetch" href="/assets/js/48.c3a6d6a1.js"><link rel="prefetch" href="/assets/js/49.85322e2d.js"><link rel="prefetch" href="/assets/js/5.99342248.js"><link rel="prefetch" href="/assets/js/50.b0bbde75.js"><link rel="prefetch" href="/assets/js/51.2c1ca7d2.js"><link rel="prefetch" href="/assets/js/52.3f1253c2.js"><link rel="prefetch" href="/assets/js/53.daf45b01.js"><link rel="prefetch" href="/assets/js/54.f7ca787a.js"><link rel="prefetch" href="/assets/js/55.a3558a62.js"><link rel="prefetch" href="/assets/js/56.8bbbd74b.js"><link rel="prefetch" href="/assets/js/57.3d9a654a.js"><link rel="prefetch" href="/assets/js/58.371aba3f.js"><link rel="prefetch" href="/assets/js/59.144e39c6.js"><link rel="prefetch" href="/assets/js/6.5e1bc5dd.js"><link rel="prefetch" href="/assets/js/60.206644a5.js"><link rel="prefetch" href="/assets/js/61.409ad486.js"><link rel="prefetch" href="/assets/js/62.f532e815.js"><link rel="prefetch" href="/assets/js/63.dec8c82f.js"><link rel="prefetch" href="/assets/js/64.5d3f2f49.js"><link rel="prefetch" href="/assets/js/65.ad8dc4ad.js"><link rel="prefetch" href="/assets/js/66.7b6aea9c.js"><link rel="prefetch" href="/assets/js/67.85eb514e.js"><link rel="prefetch" href="/assets/js/68.f38ca162.js"><link rel="prefetch" href="/assets/js/69.18d5a5e2.js"><link rel="prefetch" href="/assets/js/70.47094fe0.js"><link rel="prefetch" href="/assets/js/71.c36c918d.js"><link rel="prefetch" href="/assets/js/72.8701896c.js"><link rel="prefetch" href="/assets/js/73.3aa5c30a.js"><link rel="prefetch" href="/assets/js/74.49e45faf.js"><link rel="prefetch" href="/assets/js/75.07010724.js"><link rel="prefetch" href="/assets/js/76.0b1af361.js"><link rel="prefetch" href="/assets/js/77.1665c6ee.js"><link rel="prefetch" href="/assets/js/78.92c97532.js"><link rel="prefetch" href="/assets/js/79.13a640b6.js"><link rel="prefetch" href="/assets/js/8.a3be066d.js"><link rel="prefetch" href="/assets/js/80.69a92bd1.js"><link rel="prefetch" href="/assets/js/81.0017df37.js"><link rel="prefetch" href="/assets/js/82.a9a9f1fe.js"><link rel="prefetch" href="/assets/js/83.55e47978.js"><link rel="prefetch" href="/assets/js/84.cdd65e20.js"><link rel="prefetch" href="/assets/js/85.395b9c80.js"><link rel="prefetch" href="/assets/js/86.359dbfb0.js"><link rel="prefetch" href="/assets/js/87.9cc8a410.js"><link rel="prefetch" href="/assets/js/88.0486dff5.js"><link rel="prefetch" href="/assets/js/89.161db210.js"><link rel="prefetch" href="/assets/js/9.0bf00313.js"><link rel="prefetch" href="/assets/js/90.06ad8d79.js"><link rel="prefetch" href="/assets/js/91.40a45aaf.js"><link rel="prefetch" href="/assets/js/92.2e5b1536.js"><link rel="prefetch" href="/assets/js/93.37f734ad.js"><link rel="prefetch" href="/assets/js/94.645fc157.js"><link rel="prefetch" href="/assets/js/95.bad31250.js"><link rel="prefetch" href="/assets/js/96.04455800.js"><link rel="prefetch" href="/assets/js/97.6694059d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a54d33b6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="body" data-v-122a175c><header data-v-122a175c><div data-v-122a175c><div data-v-0bddd78f data-v-122a175c><header class="head" data-v-0bddd78f><div id="left-head" data-v-0bddd78f><a href="/" class="router-link-active" data-v-0bddd78f>FRUNOOB</a></div> <div class="search" data-v-0bddd78f><div class="search-box" data-v-0bddd78f><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></header></div></div> <div data-v-122a175c><div data-v-353dd96d data-v-122a175c><hr class="separator" data-v-353dd96d></div></div></header> <div data-v-122a175c><div class="content content__default" data-v-122a175c><h1 id="类和对象面试题"><a href="#类和对象面试题" class="header-anchor">#</a> 类和对象面试题</h1> <h2 id="_1-和-的区别"><a href="#_1-和-的区别" class="header-anchor">#</a> 1.&amp; 和 &amp;&amp; 的区别</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    &amp;运算符有两种用法：(1) 按位与；(2) 逻辑与。
    &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。
    &amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。
    很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为 username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 
</pre></details> <h2 id="_2-两个对象值相同-x-equals-y-true-但却可有不同的-hashcode-这句话对不对"><a href="#_2-两个对象值相同-x-equals-y-true-但却可有不同的-hashcode-这句话对不对" class="header-anchor">#</a> 2. 两个对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode，这句话对不对？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。
    Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br style="box-sizing:border-box;">
    (1) 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；
    (2) 如果两个对象的 hashCode 相同，它们并不一定相同。 
</pre></details> <h2 id="_3-构造器-constructor-是否可被重写-override"><a href="#_3-构造器-constructor-是否可被重写-override" class="header-anchor">#</a> 3. 构造器（constructor）是否可被重写（override）？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">   构造器不能被继承，因此不能被（子类）重写。
</pre></details> <h2 id="_4-抽象类-abstract-class-和接口-interface-有什么异同"><a href="#_4-抽象类-abstract-class-和接口-interface-有什么异同" class="header-anchor">#</a> 4. 抽象类 (abstract class) 和接口 (interface) 有什么异同？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    不同：
    1. 抽象类中可以定义构造器，接口中不可以。
    2. 抽象类可以有抽象方法和具体方法，接口中只可以有抽象方法。
    3. 抽象类中的成员可以是 private、默认、protected、public，接口中的成员全都是 public 的 (1.9 后可以有私有方法）
    4. 抽象类中可以定义成员变量，接口中定义的成员变量实际上都是常量。
    5. 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
    6. 抽象类中可以包含静态方法，接口中不能有静态方法（从 1.8 开始可以有）。
    7. 一个类只能继承一个抽象类，一个类可以实现多个接口。
    相同：
    1. 不能够实例化
    2. 可以将抽象类和接口类型作为引用类型
    3. 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类
</pre></details> <h2 id="_5-和-equals-的区别"><a href="#_5-和-equals-的区别" class="header-anchor">#</a> 5.==和 equals 的区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    equals 和== 最大的区别是一个是方法一个是运算符。 
    ==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。
    equals()：用来比较方法两个对象的内容是否相等。
    注意：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。
</pre></details> <h2 id="_6-this-和-super-区别"><a href="#_6-this-和-super-区别" class="header-anchor">#</a> 6.this 和 super 区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    this 是代表本类对象的引用。 
    super 是代表父类存储空间的标识（可以理解为父类的引用，可以操作父类的成员） 
    怎么用呢？ 
    A: 调用成员变量 
        this. 成员变量 调用本类的成员变量 
        super. 成员变量 调用父类的成员变量 
    B: 调用构造方法 
           this(...)  调用本类的构造方法 
           super(...)  调用父类的构造方法 
    C: 调用成员方法 
        this. 成员方法  调用本类的成员方法 
        super. 成员方法 调用父类的成员方法 
</pre></details> <h2 id="_7-说出-java-lang-object-类的常用方法"><a href="#_7-说出-java-lang-object-类的常用方法" class="header-anchor">#</a> 7. 说出 java.lang.Object 类的常用方法</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    (1)public boolean equals(java.lang.Object) ：比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等；
    (2)public native int hashCode() ：获取哈希码
    (3)public java.lang.String toString() ：把数据转变成字符串
    (4)public final native java.lang.Class getClass() ：获取类结构信息
    (5)protected void finalize() throws java.lang.Throwable ：垃圾回收前执行的方法
    (6)protected native Object clone() throws java.lang.CloneNotSupportedException： 克隆
    (7)public final void wait() throws java.lang.InterruptedException ：多线程中等待功能
    (8)public final native void notify()： 多线程中唤醒功能
    (9)public final native void notifyAll()： 多线程中唤醒所有等待线程的功能 
</pre></details> <h2 id="_8-string-s-new-string-xyz-创建了几个-string-对象"><a href="#_8-string-s-new-string-xyz-创建了几个-string-对象" class="header-anchor">#</a> 8.String s=new String(“xyz”); 创建了几个 String 对象？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    二个。
    “xyz”放在字符串常量池（如果池中已经存在 xyz 则不会再次创建）。
    new String 放在堆里。
</pre></details> <h2 id="_9-什么是字符串常量池"><a href="#_9-什么是字符串常量池" class="header-anchor">#</a> 9. 什么是字符串常量池？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串。
    在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用。如果不存在，则实例化一个字符串放到池中，并返回其引用。
</pre></details> <h2 id="_10-string-类有那些常用方法"><a href="#_10-string-类有那些常用方法" class="header-anchor">#</a> 10.String 类有那些常用方法？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">     length(): 返回字符串长度
     charAt(): 返回指定索引处的字符
     substring(): 截取字符串
     trim(): 去字符串两端空白
     split(): 分割字符串，返回一个分割后的字符串数组
     replace(): 字符串替换
     indexOf(): 返回指定字符的索引
</pre></details> <h2 id="_11-stringbuffer-和-stringbuilder-区别"><a href="#_11-stringbuffer-和-stringbuilder-区别" class="header-anchor">#</a> 11.StringBuffer 和 StringBuilder 区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    StringBuffer 是线程安全的（synchronized），而 StringBuilder 不是，所以 StringBuilder 效率更高，锁的获取和释放会带来开销。
</pre></details> <h2 id="_12-访问控制符区别"><a href="#_12-访问控制符区别" class="header-anchor">#</a> 12. 访问控制符区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><table style="box-sizing:border-box;border-collapse:collapse;border-spacing:0px;display:block;width:467px;overflow:auto;margin-top:0px;margin-bottom:16px;"><tbody style="box-sizing:border-box;"><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">访问控制符</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">当前类</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">同一包</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">子类</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">其他包</td></tr><tr style="box-sizing:border-box;background-color:rgb(246, 248, 250);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">public</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td></tr><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">protected</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td></tr><tr style="box-sizing:border-box;background-color:rgb(246, 248, 250);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">default</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td></tr><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">private</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">Y</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">N</td></tr></tbody></table></details> <h2 id="_13-static-关键字作用"><a href="#_13-static-关键字作用" class="header-anchor">#</a> 13.static 关键字作用？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">     1.static 变量（静态变量）: 不用创建对象，通过类名直接访问
     2.static 方法（静态方法）: 不用创建对象，通过类名直接访问
     3.static 代码块（静态代码块）: 类加载时执行一次
 </pre></details> <h2 id="_14-final-关键字作用"><a href="#_14-final-关键字作用" class="header-anchor">#</a> 14.final 关键字作用？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    1. 修饰类：类不能被继承
    2. 修饰方法：方法不能被重写
    3. 变量：变量值不能被修改
</pre></details> <h2 id="_15-面向对象五大基本原则"><a href="#_15-面向对象五大基本原则" class="header-anchor">#</a> 15. 面向对象五大基本原则？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    1. 单一职责原则：一个类，最好只做一件事，只有一个引起他的变化。
    2. 开放封闭原则：对扩展开放，对修改封闭。
    3. 里氏替换原则：子类必须能够替换父类。
    4. 依赖倒置原则：依赖于抽象。
    5. 接口隔离原则：使用多个小的专门的接口，不要使用一个大的总的接口。
</pre></details> <h2 id="_16-接口和抽象类区别"><a href="#_16-接口和抽象类区别" class="header-anchor">#</a> 16. 接口和抽象类区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><table style="box-sizing:border-box;border-collapse:collapse;border-spacing:0px;display:block;width:467px;overflow:auto;margin-top:0px;margin-bottom:16px;"><tbody style="box-sizing:border-box;"><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">不同点</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">抽象类</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">接口</td></tr><tr style="box-sizing:border-box;background-color:rgb(246, 248, 250);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">关键字</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">abstract</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">interface</td></tr><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">实现</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">extends</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">implements</td></tr><tr style="box-sizing:border-box;background-color:rgb(246, 248, 250);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">构造函数</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">有</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">无</td></tr><tr style="box-sizing:border-box;background-color:rgb(255, 255, 255);border-top:1px solid rgb(198, 203, 209);"><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">属性</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">随意</td><td style="box-sizing:border-box;padding:6px 13px;border:1px solid rgb(223, 226, 229);">static final</td></tr></tbody></table></details> <h2 id="_17-重载和重写区别"><a href="#_17-重载和重写区别" class="header-anchor">#</a> 17. 重载和重写区别？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    重载：在同一个类中，方法名相同参数列表不同。与方法返回值和访问修饰符无关。
    重写：发生在父子类中，方法名、参数列表相同。抛出异常小于等于父类，访问修饰符大于等于父类。
</pre></details> <h2 id="_18-java-创建对象有几种方式"><a href="#_18-java-创建对象有几种方式" class="header-anchor">#</a> 18. Java 创建对象有几种方式？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    java 中提供了以下四种创建对象的方式：
    1. new 创建新对象
    2. 通过反射机制
    3. 采用 clone 机制
    4. 通过序列化机制
</pre></details> <h2 id="_19-java-中会存在内存泄漏吗-请简单描述。"><a href="#_19-java-中会存在内存泄漏吗-请简单描述。" class="header-anchor">#</a> 19. Java 中会存在内存泄漏吗，请简单描述。</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:16px;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题；然而在实际开发中也会。
    java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 的内存泄露。
</pre></details> <h2 id="_20-说明内存泄漏和内存溢出的区别和联系"><a href="#_20-说明内存泄漏和内存溢出的区别和联系" class="header-anchor">#</a> 20. 说明内存泄漏和内存溢出的区别和联系？</h2> <details style="box-sizing:border-box;display:block;margin-top:0px;margin-bottom:0px !important;"><summary style="box-sizing:border-box;touch-action:manipulation;display:list-item;cursor:pointer;outline:none;">参考答案</summary><pre style="box-sizing:border-box;font-size:14px;font-family:SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;margin-top:0px;margin-bottom:1rem;overflow:visible;display:block;color:rgb(33, 37, 41);position:relative;word-break:break-all;border-radius:4px;white-space:pre-wrap;">    内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现 out of memory；比如申请了一个 integer, 但给它存了 long 才能存下的数，那就是内存溢出。
    内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。
    memory leak 会最终会导致 out of memory！</pre></details></div></div> <div class="bottom" data-v-122a175c><div class="bleft" data-v-122a175c><a href="javascript:history.go(-1)" data-v-122a175c>👈返回上一页</a></div> <div class="bright" data-v-122a175c><a href="https://github.com/frunoob/journal/edit/master/journal/list/20220218153334.md" target="_blank" data-v-122a175c>✏️修改此页面</a></div></div> <hr data-v-122a175c> <div class="footer" data-v-122a175c><p data-v-122a175c>终归是空无，不如燃烧 </p> <p data-v-122a175c>frunoob@qq.com</p></div></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.42784d71.js" defer></script><script src="/assets/js/10.5f3a76f7.js" defer></script><script src="/assets/js/3.9a2ec5a7.js" defer></script><script src="/assets/js/7.f44fb539.js" defer></script><script src="/assets/js/34.b96ec4f2.js" defer></script><script src="/assets/js/11.bea036dd.js" defer></script>
  </body>
</html>
